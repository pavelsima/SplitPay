{
  "version": 3,
  "sources": ["../../@formkit/utils/dist/index.mjs", "../../@formkit/core/dist/index.mjs", "../../@formkit/inputs/dist/index.mjs", "../../@formkit/rules/dist/index.mjs", "../../@formkit/observer/dist/index.mjs", "../../@formkit/validation/dist/index.mjs", "../../@formkit/i18n/dist/index.mjs", "../../@formkit/dev/dist/index.mjs", "../../@formkit/vue/dist/index.mjs"],
  "sourcesContent": ["/**\n * Generates a random string.\n * @returns string\n * @public\n */\nfunction token() {\n    return Math.random().toString(36).substring(2, 15);\n}\n/**\n * Creates a new set of the specified type and uses the values from an Array or\n * an existing Set.\n * @param items -\n * @returns Set\n * @public\n */\nfunction setify(items) {\n    return items instanceof Set ? items : new Set(items);\n}\n/**\n * Given 2 arrays, return them as a combined array with no duplicates.\n * @param arr1 -\n * @param arr2 -\n * @returns any[]\n * @public\n */\nfunction dedupe(arr1, arr2) {\n    const original = arr1 instanceof Set ? arr1 : new Set(arr1);\n    if (arr2)\n        arr2.forEach((item) => original.add(item));\n    return [...original];\n}\n/**\n * Checks if the given property exists on the given object.\n * @param obj -\n * @param property -\n * @public\n */\nfunction has(obj, property) {\n    return Object.prototype.hasOwnProperty.call(obj, property);\n}\n/**\n * Compare two values for equality optionally at depth.\n * @param valA - Any type of input\n * @param valB - Any type of output\n * @param deep - Indicate if we should recurse into the object\n * @returns boolean\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction eq(valA, valB, deep = true) {\n    if (valA === valB)\n        return true;\n    if (typeof valA === typeof valB && typeof valA === 'object') {\n        if (valA instanceof Map)\n            return false;\n        if (valA instanceof Set)\n            return false;\n        if (Object.keys(valA).length !== Object.keys(valB).length)\n            return false;\n        for (const key in valA) {\n            if (!(key in valB))\n                return false;\n            if (valA[key] !== valB[key] && !deep)\n                return false;\n            if (deep && !eq(valA[key], valB[key], true))\n                return false;\n        }\n        return true;\n    }\n    return false;\n}\n/**\n * Determines if a value is empty or not.\n * @param value - any type of value that could be returned by an input.\n * @public\n */\nfunction empty(value // eslint-disable-line\n) {\n    const type = typeof value;\n    if (type === 'number')\n        return false;\n    if (value === undefined)\n        return true;\n    if (type === 'string') {\n        return value === '';\n    }\n    if (type === 'object') {\n        if (value === null)\n            return true;\n        for (const _i in value)\n            return false;\n        return true;\n    }\n    return false;\n}\n/**\n * Escape a string for use in regular expressions.\n * @param string - The string to escape.\n * @public\n */\nfunction escapeExp(string) {\n    // $& means the whole matched string\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n/**\n * Given a string format (date) return a regex to match against.\n * @param format - The format of the string\n * @returns\n * @public\n */\nfunction regexForFormat(format) {\n    const escaped = `^${escapeExp(format)}$`;\n    const formats = {\n        MM: '(0[1-9]|1[012])',\n        M: '([1-9]|1[012])',\n        DD: '([012][0-9]|3[01])',\n        D: '([012]?[0-9]|3[01])',\n        YYYY: '\\\\d{4}',\n        YY: '\\\\d{2}',\n    };\n    const tokens = Object.keys(formats);\n    return new RegExp(tokens.reduce((regex, format) => {\n        return regex.replace(format, formats[format]);\n    }, escaped));\n}\n/**\n * Given a FormKit input type\n * @param type - Any FormKit input type\n * @public\n */\nfunction nodeType(type) {\n    const t = type.toLowerCase();\n    if (t === 'list')\n        return 'list';\n    if (t === 'group')\n        return 'group';\n    return 'input';\n}\n/**\n * Determines if an object is an object or not.\n * @param o - any value\n * @returns\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction isObject(o) {\n    return Object.prototype.toString.call(o) === '[object Object]';\n}\n/**\n * Attempts to determine if an object is a plain object. Mostly lifted from\n * is-plain-object: https://github.com/jonschlinkert/is-plain-object\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * @param o - any value\n * @returns\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction isPojo(o) {\n    if (isObject(o) === false)\n        return false;\n    if (o.__FKNode__ || o.__POJO__ === false)\n        return false;\n    const ctor = o.constructor;\n    if (ctor === undefined)\n        return true;\n    const prot = ctor.prototype;\n    if (isObject(prot) === false)\n        return false;\n    if (prot.hasOwnProperty('isPrototypeOf') === false) {\n        return false;\n    }\n    return true;\n}\n/**\n * Recursively merge data from additional into original returning a new object.\n * @param original - An object to extend\n * @param additional - An object to modify the original object with.\n * @param arrays - By default replaces arrays, but can also append to them.\n * @param ignoreUndefined - when true it treats undefined values as if they dont exist\n * @public\n */\nfunction extend(original, additional, extendArrays = false, ignoreUndefined = false) {\n    if (additional === null)\n        return null;\n    const merged = {};\n    if (typeof additional === 'string')\n        return additional;\n    for (const key in original) {\n        if (has(additional, key) &&\n            (additional[key] !== undefined || !ignoreUndefined)) {\n            if (extendArrays &&\n                Array.isArray(original[key]) &&\n                Array.isArray(additional[key])) {\n                merged[key] = original[key].concat(additional[key]);\n                continue;\n            }\n            if (additional[key] === undefined) {\n                continue;\n            }\n            if (isPojo(original[key]) && isPojo(additional[key])) {\n                merged[key] = extend(original[key], additional[key], extendArrays, ignoreUndefined);\n            }\n            else {\n                merged[key] = additional[key];\n            }\n        }\n        else {\n            merged[key] = original[key];\n        }\n    }\n    for (const key in additional) {\n        if (!has(merged, key) && additional[key] !== undefined) {\n            merged[key] = additional[key];\n        }\n    }\n    return merged;\n}\n/**\n * Determine if the given string is fully quoted. Examples:\n * hello - false\n * \"hello\" - true\n * 'world' - true\n * \"hello\"==\"world\" - false\n * \"hello'this'\" - false\n * \"hello\"'there' - false\n * \"hello\"\"there\" - false\n * 'hello === world' - true\n * @param str - A string to check.\n * @public\n */\nfunction isQuotedString(str) {\n    // quickly return false if the value is note quoted\n    if (str[0] !== '\"' && str[0] !== \"'\")\n        return false;\n    if (str[0] !== str[str.length - 1])\n        return false;\n    const quoteType = str[0];\n    for (let p = 1; p < str.length; p++) {\n        if (str[p] === quoteType &&\n            (p === 1 || str[p - 1] !== '\\\\') &&\n            p !== str.length - 1) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Remove extra escape characters.\n * @param str - A string to remove escape characters from.\n * @public\n */\nfunction rmEscapes(str) {\n    if (!str.length)\n        return '';\n    let clean = '';\n    let lastChar = '';\n    for (let p = 0; p < str.length; p++) {\n        const char = str.charAt(p);\n        if (char !== '\\\\' || lastChar === '\\\\') {\n            clean += char;\n        }\n        lastChar = char;\n    }\n    return clean;\n}\n/**\n * Performs a recursive Object.assign like operation.\n * @param a - An object to be extended by object b\n * @param b - An object to copy values from\n * @public\n */\nfunction assignDeep(a, b) {\n    for (const key in a) {\n        if (has(b, key) &&\n            a[key] !== b[key] &&\n            !(isPojo(a[key]) && isPojo(b[key]))) {\n            a[key] = b[key];\n        }\n        else if (isPojo(a[key]) && isPojo(b[key])) {\n            assignDeep(a[key], b[key]);\n        }\n    }\n    for (const key in b) {\n        if (!has(a, key)) {\n            a[key] = b[key];\n        }\n    }\n    return a;\n}\n/**\n * Filters out values from an object that should not be considered \"props\" of\n * a core node, like \"value\" and \"name\".\n * @param attrs - An object to extract core node config from.\n * @public\n */\nfunction nodeProps(...sets) {\n    return sets.reduce((valid, props) => {\n        const { value, name, modelValue, config, plugins, ...validProps } = props; // eslint-disable-line\n        return Object.assign(valid, validProps);\n    }, {});\n}\n/**\n * Parse a string for comma-separated arguments\n * @param str - A string to parse\n * @public\n */\nfunction parseArgs(str) {\n    const args = [];\n    let arg = '';\n    let depth = 0;\n    let quote = '';\n    let lastChar = '';\n    for (let p = 0; p < str.length; p++) {\n        const char = str.charAt(p);\n        if (char === quote && lastChar !== '\\\\') {\n            quote = '';\n        }\n        else if ((char === \"'\" || char === '\"') && !quote && lastChar !== '\\\\') {\n            quote = char;\n        }\n        else if (char === '(' && !quote) {\n            depth++;\n        }\n        else if (char === ')' && !quote) {\n            depth--;\n        }\n        if (char === ',' && !quote && depth === 0) {\n            if (isQuotedString(arg))\n                arg = rmEscapes(arg.substr(1, arg.length - 2));\n            args.push(arg);\n            arg = '';\n        }\n        else if (char !== ' ' || quote) {\n            arg += char;\n        }\n        lastChar = char;\n    }\n    if (arg) {\n        if (isQuotedString(arg))\n            arg = rmEscapes(arg.substr(1, arg.length - 2));\n        args.push(arg);\n    }\n    return args;\n}\n/**\n * Return a new (shallow) object with all properties from a given object\n * that are present in the array.\n * @param obj - An object to clone\n * @param toRemove - An array of keys to remove\n * @public\n */\nfunction except(obj, toRemove) {\n    const clean = {};\n    const exps = toRemove.filter((n) => n instanceof RegExp);\n    const keysToRemove = new Set(toRemove);\n    for (const key in obj) {\n        if (!keysToRemove.has(key) && !exps.some((exp) => exp.test(key))) {\n            clean[key] = obj[key];\n        }\n    }\n    return clean;\n}\n/**\n * Extracts a set of keys from a given object. Importantly, this will extract\n * values even if they are not set on the original object they will just have an\n * undefined value.\n * @param obj - An object to extract values from\n * @param include - A set of keys to extract\n * @returns\n * @public\n */\nfunction only(obj, include) {\n    const clean = {};\n    const exps = include.filter((n) => n instanceof RegExp);\n    include.forEach((key) => {\n        if (!(key instanceof RegExp)) {\n            clean[key] = obj[key];\n        }\n    });\n    Object.keys(obj).forEach((key) => {\n        if (exps.some((exp) => exp.test(key))) {\n            clean[key] = obj[key];\n        }\n    });\n    return clean;\n}\n/**\n * This converts kebab-case to camelCase. It ONLY converts from kebab for\n * efficiency stake.\n * @param str - String to convert.\n * @public\n */\nfunction camel(str) {\n    return str.replace(/-([a-z0-9])/gi, (_s, g) => g.toUpperCase());\n}\n/**\n * This converts camel-case to kebab case. It ONLY converts from camel to kebab.\n * @param str - Converts camel to kebab\n * @returns\n * @public\n */\nfunction kebab(str) {\n    return str\n        .replace(/([a-z0-9])([A-Z])/g, (_s, trail, cap) => trail + '-' + cap.toLowerCase())\n        .replace(' ', '-')\n        .toLowerCase();\n}\n/**\n * Perform a recursive clone on a given object. This only intended to be used\n * for simple objects like arrays and pojos.\n * @param obj - Object to clone\n * @public\n */\nfunction clone(obj) {\n    if (obj === null ||\n        obj instanceof RegExp ||\n        obj instanceof Date ||\n        (typeof File === 'function' && obj instanceof File))\n        return obj;\n    if (Array.isArray(obj)) {\n        return obj.map((value) => {\n            if (typeof value === 'object')\n                return clone(value);\n            return value;\n        });\n    }\n    return Object.keys(obj).reduce((newObj, key) => {\n        newObj[key] =\n            typeof obj[key] === 'object' ? clone(obj[key]) : obj[key];\n        return newObj;\n    }, {});\n}\n/**\n * Clones anything. If the item is scalar, no worries, it passes it back. if it\n * is an object, it performs a (fast/loose) clone operation.\n * @param obj - The object to clone\n * @public\n */\nfunction cloneAny(obj) {\n    return typeof obj === 'object'\n        ? clone(obj)\n        : obj;\n}\n/**\n * Get a specific value via dot notation.\n * @param obj - An object to fetch data from\n * @param addr - An \"address\" in dot notation\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction getAt(obj, addr) {\n    if (!obj || typeof obj !== 'object')\n        return null;\n    const segments = addr.split('.');\n    let o = obj;\n    for (const i in segments) {\n        const segment = segments[i];\n        if (has(o, segment)) {\n            o = o[segment];\n        }\n        if (+i === segments.length - 1)\n            return o;\n        if (!o || typeof o !== 'object')\n            return null;\n    }\n    return null;\n}\n/**\n * Determines if the value of a prop that is either present (true) or not\n * present (false). For example the prop disabled should disable\n * by just existing, but what if it is set to the string \"false\" \u2014 then it\n * should not be disabled.\n * @param value - value to be checked\n * @returns\n * @public\n */\nfunction undefine(value) {\n    return value !== undefined && value !== 'false' && value !== false\n        ? true\n        : undefined;\n}\n/**\n * Defines an object as an initial value.\n * @param obj - Object\n * @returns\n * @public\n */\n/* eslint-disable-next-line @typescript-eslint/ban-types */\nfunction init(obj) {\n    return Object.defineProperty(obj, '__init', {\n        enumerable: false,\n        value: true,\n    });\n}\n/**\n * Turn any string into a URL/DOM safe string.\n * @public\n */\nfunction slugify(str) {\n    return str\n        .normalize('NFD')\n        .replace(/[\\u0300-\\u036f]/g, '')\n        .toLowerCase()\n        .replace(/[^a-z0-9]/g, ' ')\n        .trim()\n        .replace(/\\s+/g, '-');\n}\n\nexport { assignDeep, camel, clone, cloneAny, dedupe, empty, eq, escapeExp, except, extend, getAt, has, init, isObject, isPojo, isQuotedString, kebab, nodeProps, nodeType, only, parseArgs, regexForFormat, rmEscapes, setify, slugify, token, undefine };\n", "import { token, slugify, has, cloneAny, init, eq, camel, undefine, kebab, dedupe, parseArgs, getAt, isQuotedString, rmEscapes } from '@formkit/utils';\n\n/**\n * Creates a new dispatcher that allows the addition/removal of middleware\n * functions, and the ability to dispatch a payload to all middleware.\n * @returns FormKitDispatcher\n */\nfunction createDispatcher() {\n    const middleware = [];\n    let currentIndex = 0;\n    const use = (dispatchable) => middleware.push(dispatchable);\n    const dispatch = (payload) => {\n        const current = middleware[currentIndex];\n        if (typeof current === 'function') {\n            return current(payload, (explicitPayload) => {\n                currentIndex++;\n                return dispatch(explicitPayload === undefined ? payload : explicitPayload);\n            });\n        }\n        currentIndex = 0;\n        return payload;\n    };\n    use.dispatch = dispatch;\n    use.unshift = (dispatchable) => middleware.unshift(dispatchable);\n    use.remove = (dispatchable) => {\n        const index = middleware.indexOf(dispatchable);\n        if (index > -1)\n            middleware.splice(index, 1);\n    };\n    return use;\n}\n\n/**\n * Creates a new event emitter, each node uses one of these to allow it to emit\n * events to local listeners and tree listeners.\n * @returns FormKitEventEmitter\n */\nfunction createEmitter() {\n    const listeners = new Map();\n    const receipts = new Map();\n    let buffer = undefined;\n    const emitter = (node, event) => {\n        if (buffer) {\n            buffer.set(event.name, [node, event]);\n            return;\n        }\n        if (listeners.has(event.name)) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            listeners.get(event.name).forEach((wrapper) => {\n                if (event.origin === node || wrapper.modifiers.includes('deep')) {\n                    wrapper.listener(event);\n                }\n            });\n        }\n        if (event.bubble) {\n            node.bubble(event);\n        }\n    };\n    /**\n     * Add an event listener\n     * @param eventName - The name of the event to listen to\n     * @param listener - The callback\n     * @returns string\n     */\n    emitter.on = (eventName, listener) => {\n        const [event, ...modifiers] = eventName.split('.');\n        const receipt = listener.receipt || token();\n        const wrapper = {\n            modifiers,\n            event,\n            listener,\n            receipt,\n        };\n        /* eslint-disable @typescript-eslint/no-non-null-assertion */\n        listeners.has(event)\n            ? listeners.get(event).push(wrapper)\n            : listeners.set(event, [wrapper]);\n        receipts.has(receipt)\n            ? receipts.get(receipt).push(event)\n            : receipts.set(receipt, [event]);\n        /* eslint-enable @typescript-eslint/no-non-null-assertion */\n        return receipt;\n    };\n    /**\n     * Remove an event listener\n     * @param listenerOrReceipt - Either a receipt or the callback function.\n     */\n    emitter.off = (receipt) => {\n        var _a;\n        if (receipts.has(receipt)) {\n            (_a = receipts.get(receipt)) === null || _a === void 0 ? void 0 : _a.forEach((event) => {\n                const eventListeners = listeners.get(event);\n                if (Array.isArray(eventListeners)) {\n                    listeners.set(event, eventListeners.filter((wrapper) => wrapper.receipt !== receipt));\n                }\n            });\n            receipts.delete(receipt);\n        }\n    };\n    /**\n     * Pause emitting values. Any events emitted while paused will not be emitted\n     * but rather \"stored\" \u2014\u00A0and whichever events are emitted last will be output.\n     * For example:\n     * pause()\n     * emit('foo', 1)\n     * emit('foo', 2)\n     * emit('bar', 3)\n     * emit('bar', 4)\n     * play()\n     * // would result in\n     * emit('foo', 2)\n     * emit('bar', 4)\n     * Optionally pauses all children as well.\n     * @param node - A node to pause all children on.\n     */\n    emitter.pause = (node) => {\n        if (!buffer)\n            buffer = new Map();\n        if (node) {\n            node.walk((child) => child._e.pause());\n        }\n    };\n    /**\n     * Release the current event buffer.\n     * @param node - A node to unpause all children on.\n     */\n    emitter.play = (node) => {\n        if (!buffer)\n            return;\n        const events = buffer;\n        buffer = undefined;\n        events.forEach(([node, event]) => emitter(node, event));\n        if (node) {\n            node.walk((child) => child._e.play());\n        }\n    };\n    return emitter;\n}\n/**\n * Emit an event from this node.\n * @param node - The node that is emitting\n * @param context - The context of that node\n * @param name - The name of the event\n * @param payload - The payload to emit\n * @returns FormKitNode\n */\nfunction emit$1(node, context, name, payload, // eslint-disable-line @typescript-eslint/explicit-module-boundary-types,\nbubble = true) {\n    context._e(node, {\n        payload,\n        name,\n        bubble,\n        origin: node,\n    });\n    return node;\n}\n/**\n * Send an event from the given node up it's ancestor tree.\n * @param node -\n * @param _context -\n * @param event -\n */\nfunction bubble(node, _context, event) {\n    if (isNode(node.parent)) {\n        node.parent._e(node.parent, event);\n    }\n    return node;\n}\n/**\n * Adds an event listener to the node for a specific event. The event name is a\n * simple string matching the name of the event to listen to. It can optionally\n * include modifiers like eventName.deep\n * @param node -\n * @param context -\n * @param name -\n * @param listener -\n * @returns FormKitNode\n */\nfunction on(_node, context, name, listener) {\n    return context._e.on(name, listener);\n}\n/**\n * Removes an event listener from a node by the returned receipt from .on().\n * @param node - The node to remote the listener from\n * @param context - The context to remove\n * @param receipt - The receipt returned by .on()\n * @returns FormKitNode\n */\nfunction off(node, context, receipt) {\n    context._e.off(receipt);\n    return node;\n}\n\n/**\n * FormKit's global error handler.\n * @public\n */\nconst errorHandler = createDispatcher();\n/**\n * The default error handler just sets the error as the message.\n */\nerrorHandler((error, next) => {\n    if (!error.message)\n        error.message = String(`E${error.code}`);\n    return next(error);\n});\n/**\n * FormKit's global warning handler.\n * @public\n */\nconst warningHandler = createDispatcher();\nwarningHandler((warning, next) => {\n    if (!warning.message)\n        warning.message = String(`W${warning.code}`);\n    const result = next(warning);\n    if (console && typeof console.warn === 'function')\n        console.warn(result.message);\n    return result;\n});\n/**\n * Globally emits a warning.\n * @param code - The integer error code.\n * @param data - Usually an object of information to include.\n * @public\n */\nfunction warn(code, data = {}) {\n    warningHandler.dispatch({ code, data });\n}\n/**\n * Emits an error, generally should result in an exception.\n * @param code - The integer error code.\n * @param data - Usually an object of information to include.\n * @public\n */\nfunction error(code, data = {}) {\n    throw Error(errorHandler.dispatch({ code, data }).message);\n}\n\n/**\n * Creates a new FormKitMessage object.\n * @param conf - The message configuration\n * @returns FormKitMessage\n * @public\n */\nfunction createMessage(conf, node) {\n    const m = {\n        blocking: false,\n        key: token(),\n        meta: {},\n        type: 'state',\n        visible: true,\n        ...conf,\n    };\n    if (node && m.value && m.meta.localize !== false) {\n        m.value = node.t(m);\n        m.meta.locale = node.config.locale;\n    }\n    return m;\n}\n/**\n * The available traps on the node's store.\n */\nconst storeTraps = {\n    apply: applyMessages,\n    set: setMessage,\n    remove: removeMessage,\n    filter: filterMessages,\n    reduce: reduceMessages,\n    release: releaseBuffer,\n    touch: touchMessages,\n};\n/**\n * Creates a new FormKit message store.\n * @returns FormKitStore\n */\nfunction createStore(_buffer = false) {\n    const messages = {};\n    let node;\n    let buffer = _buffer;\n    let _b = [];\n    const _m = new Map();\n    let _r = undefined;\n    const store = new Proxy(messages, {\n        get(...args) {\n            const [_target, property] = args;\n            if (property === 'buffer')\n                return buffer;\n            if (property === '_b')\n                return _b;\n            if (property === '_m')\n                return _m;\n            if (property === '_r')\n                return _r;\n            if (has(storeTraps, property)) {\n                return storeTraps[property].bind(null, messages, store, node);\n            }\n            return Reflect.get(...args);\n        },\n        set(_t, prop, value) {\n            if (prop === '_n') {\n                node = value;\n                if (_r === '__n')\n                    releaseMissed(node, store);\n                return true;\n            }\n            else if (prop === '_b') {\n                _b = value;\n                return true;\n            }\n            else if (prop === 'buffer') {\n                buffer = value;\n                return true;\n            }\n            else if (prop === '_r') {\n                _r = value;\n                return true;\n            }\n            error(101, node);\n            return false;\n        },\n    });\n    return store;\n}\n/**\n * Adds a new value to a FormKit message bag.\n * @param store - The store itself\n * @param store - The store interface\n * @param node - The node this store belongs to\n * @param message - The message object\n * @returns FormKitStore\n */\nfunction setMessage(messageStore, store, node, message) {\n    if (store.buffer) {\n        store._b.push([[message]]);\n        return store;\n    }\n    if (messageStore[message.key] !== message) {\n        if (typeof message.value === 'string' && message.meta.localize !== false) {\n            // Expose the value to translation\n            const previous = message.value;\n            message.value = node.t(message);\n            if (message.value !== previous) {\n                message.meta.locale = node.props.locale;\n            }\n        }\n        const e = `message-${has(messageStore, message.key) ? 'updated' : 'added'}`;\n        messageStore[message.key] = Object.freeze(message);\n        node.emit(e, message);\n    }\n    return store;\n}\n/**\n * Run through each message in the store, and ensure it has been translated\n * to the proper language. This most frequently happens after a locale change.\n */\nfunction touchMessages(messageStore, store) {\n    for (const key in messageStore) {\n        const message = { ...messageStore[key] };\n        store.set(message);\n    }\n}\n/**\n * Remove a message from the store.\n * @param store - The store itself\n * @param store - The store interface\n * @param node - The node this store belongs to\n * @param key - The message key\n * @returns FormKitStore\n */\nfunction removeMessage(messageStore, store, node, key) {\n    if (has(messageStore, key)) {\n        const message = messageStore[key];\n        delete messageStore[key];\n        node.emit('message-removed', message);\n    }\n    if (store.buffer === true) {\n        store._b = store._b.filter((buffered) => {\n            buffered[0] = buffered[0].filter((m) => m.key !== key);\n            return buffered[1] || buffered[0].length;\n        });\n    }\n    return store;\n}\n/**\n * Iterates over all messages removing those that are no longer wanted.\n * @param messageStore - The store itself\n * @param store - The store interface\n * @param node - The node to filter for\n * @param callback - A callback accepting a message and returning a boolean\n * @param type - Pre filtered by a given message type\n */\nfunction filterMessages(messageStore, store, node, callback, type) {\n    for (const key in messageStore) {\n        const message = messageStore[key];\n        if ((!type || message.type === type) && !callback(message)) {\n            removeMessage(messageStore, store, node, key);\n        }\n    }\n}\n/**\n * Reduce the message store to some other generic value.\n * @param messageStore - The store itself\n * @param _store - Unused but curried \u2014 the store interface itself\n * @param _node - The node owner of this store\n * @param reducer - The callback that performs the reduction\n * @param accumulator - The initial value\n * @returns\n */\nfunction reduceMessages(messageStore, _store, _node, reducer, accumulator) {\n    for (const key in messageStore) {\n        const message = messageStore[key];\n        accumulator = reducer(accumulator, message);\n    }\n    return accumulator;\n}\n/**\n *\n * @param messageStore - The store itself\n * @param _store - Unused but curried \u2014 the store interface itself\n * @param node - The node owner of this store\n * @param messages - An array of FormKitMessages to apply to this input, or an object of messages to apply to children.\n */\nfunction applyMessages(_messageStore, store, node, messages, clear) {\n    if (Array.isArray(messages)) {\n        if (store.buffer) {\n            store._b.push([messages, clear]);\n            return;\n        }\n        // In this case we are applying messages to this node\u2019s store.\n        const applied = new Set(messages.map((message) => {\n            store.set(message);\n            return message.key;\n        }));\n        // Remove any messages that were not part of the initial apply:\n        if (typeof clear === 'string') {\n            store.filter((message) => message.type !== clear || applied.has(message.key));\n        }\n        else if (typeof clear === 'function') {\n            store.filter((message) => !clear(message) || applied.has(message.key));\n        }\n    }\n    else {\n        for (const address in messages) {\n            const child = node.at(address);\n            if (child) {\n                child.store.apply(messages[address], clear);\n            }\n            else {\n                missed(node, store, address, messages[address], clear);\n            }\n        }\n    }\n}\n/**\n * Creates an array of message arrays from strings.\n * @param errors - Arrays or objects of form errors or input errors\n * @returns\n * @internal\n */\nfunction createMessages(node, ...errors) {\n    const sourceKey = `${node.name}-set`;\n    const make = (error) => createMessage({\n        key: slugify(error),\n        type: 'error',\n        value: error,\n        meta: { source: sourceKey },\n    });\n    return errors\n        .filter((m) => !!m)\n        .map((errorSet) => {\n        if (typeof errorSet === 'string')\n            errorSet = [errorSet];\n        if (Array.isArray(errorSet)) {\n            return errorSet.map((error) => make(error));\n        }\n        else {\n            const errors = {};\n            for (const key in errorSet) {\n                if (Array.isArray(errorSet[key])) {\n                    errors[key] = errorSet[key].map((error) => make(error));\n                }\n                else {\n                    errors[key] = [make(errorSet[key])];\n                }\n            }\n            return errors;\n        }\n    });\n}\n/**\n *\n * @param store - The store to apply this missed applications.\n * @param address - The address that was missed (a node path that didn't yet exist)\n * @param messages - The messages that should have been applied.\n * @param clear - The clearing function (if any)\n */\nfunction missed(node, store, address, messages, clear) {\n    var _a;\n    const misses = store._m;\n    if (!misses.has(address))\n        misses.set(address, []);\n    // The created receipt\n    if (!store._r)\n        store._r = releaseMissed(node, store);\n    (_a = misses.get(address)) === null || _a === void 0 ? void 0 : _a.push([messages, clear]);\n}\n/**\n * Releases messages that were applied to a child via parent, but the child did\n * not exist. Once the child does exist, the created event for that child will\n * bubble to this point, and any stored applications will be applied serially.\n * @param store - The store object.\n * @returns\n */\nfunction releaseMissed(node, store) {\n    return node.on('child.deep', ({ payload: child }) => {\n        store._m.forEach((misses, address) => {\n            if (node.at(address) === child) {\n                misses.forEach(([messages, clear]) => {\n                    child.store.apply(messages, clear);\n                });\n                store._m.delete(address);\n            }\n        });\n        // If all the stored misses were applied, remove the listener.\n        if (store._m.size === 0 && store._r) {\n            node.off(store._r);\n            store._r = undefined;\n        }\n    });\n}\n/**\n * Iterates over all buffered messages and applies them in sequence.\n * @param messageStore - The store itself\n * @param store - The store interface\n * @param node - The node to filter for\n */\nfunction releaseBuffer(_messageStore, store) {\n    store.buffer = false;\n    store._b.forEach(([messages, clear]) => store.apply(messages, clear));\n    store._b = [];\n}\n\n/**\n * Creates a new ledger for use on a single node's context.\n * @returns\n */\nfunction createLedger() {\n    const ledger = {};\n    let n;\n    return {\n        count: (...args) => createCounter(n, ledger, ...args),\n        init(node) {\n            n = node;\n            node.on('message-added.deep', add(ledger, 1));\n            node.on('message-removed.deep', add(ledger, -1));\n        },\n        merge: (child) => merge(n, ledger, child),\n        settled(counterName) {\n            return has(ledger, counterName)\n                ? ledger[counterName].promise\n                : Promise.resolve();\n        },\n        unmerge: (child) => merge(n, ledger, child, true),\n        value(counterName) {\n            return has(ledger, counterName) ? ledger[counterName].count : 0;\n        },\n    };\n}\n/**\n * Creates a new counter object in the counting ledger.\n * @param ledger - The actual ledger storage object\n * @param counterName - The name of the counter, can be arbitrary\n * @param condition - The condition function (or string) that filters messages\n * @param initialValue - The initial counter value\n * @returns\n */\nfunction createCounter(node, ledger, counterName, condition, increment = 0) {\n    condition = parseCondition(condition || counterName);\n    if (!has(ledger, counterName)) {\n        const counter = {\n            condition,\n            count: 0,\n            name: counterName,\n            node,\n            promise: Promise.resolve(),\n            resolve: () => { }, // eslint-disable-line @typescript-eslint/no-empty-function\n        };\n        ledger[counterName] = counter;\n        increment = node.store.reduce((sum, m) => sum + counter.condition(m) * 1, increment);\n        node.each((child) => {\n            child.ledger.count(counter.name, counter.condition);\n            increment += child.ledger.value(counter.name);\n        });\n    }\n    return count(ledger[counterName], increment).promise;\n}\n/**\n * We parse the condition to allow flexibility in how counters are specified.\n * @param condition - The condition that, if true, allows a message to change a counter's value\n * @returns\n */\nfunction parseCondition(condition) {\n    if (typeof condition === 'function') {\n        return condition;\n    }\n    return (m) => m.type === condition;\n}\n/**\n * Perform a counting action on the a given counter object of the ledger.\n * @param counter - A counter object\n * @param increment - The amount by which we are changing the count value\n * @returns\n */\nfunction count(counter, increment) {\n    const initial = counter.count;\n    const post = counter.count + increment;\n    counter.count = post;\n    if (initial === 0 && post !== 0) {\n        counter.node.emit(`unsettled:${counter.name}`, counter.count, false);\n        counter.promise = new Promise((r) => (counter.resolve = r));\n    }\n    else if (initial !== 0 && post === 0) {\n        counter.node.emit(`settled:${counter.name}`, counter.count, false);\n        counter.resolve();\n    }\n    counter.node.emit(`count:${counter.name}`, counter.count, false);\n    return counter;\n}\n/**\n * Returns a function to be used as an event listener for message events.\n * @param ledger - A ledger to operate on\n * @param delta - The amount to add or subtract\n * @returns\n */\nfunction add(ledger, delta) {\n    return (e) => {\n        for (const name in ledger) {\n            const counter = ledger[name];\n            if (counter.condition(e.payload)) {\n                count(counter, delta);\n            }\n        }\n    };\n}\n/**\n * Given a child node, add the parent node's counters to the child and then\n * rectify the upstream ledger counts. Generally used when attaching a child\n * to an already counted tree.\n * @param parent - The parent that is \"receiving\" the child\n * @param ledger - The ledger object\n * @param child - The child (can be a subtree) that is being attached\n */\nfunction merge(parent, ledger, child, remove = false) {\n    for (const key in ledger) {\n        const condition = ledger[key].condition;\n        if (!remove)\n            child.ledger.count(key, condition);\n        const increment = child.ledger.value(key) * (remove ? -1 : 1);\n        if (!parent)\n            continue;\n        do {\n            parent.ledger.count(key, condition, increment);\n            parent = parent.parent;\n        } while (parent);\n    }\n}\n\n/**\n * A global registry of nodes by their alias or name (if root).\n */\nconst registry = new Map();\nconst reflected = new Map();\n/**\n * An event emitter for registered/set/unset nodes\n */\nconst emit = createEmitter();\n/**\n * Receipts of listeners.\n */\nconst receipts = [];\n/**\n * Registers a node to the registry _if_ the node is a root node, _or_ if the\n * node has an explicit node.props.alias. If these two things are not true\n * then no node is registered (idempotent).\n *\n * @param node - A node to register\n * @public\n */\nfunction register(node) {\n    if (node.props.id) {\n        registry.set(node.props.id, node);\n        reflected.set(node, node.props.id);\n        emit(node, {\n            payload: node,\n            name: node.props.id,\n            bubble: false,\n            origin: node,\n        });\n    }\n}\n/**\n * Deregister a node from the registry.\n * @param node - A node to remove\n * @public\n */\nfunction deregister(node) {\n    if (reflected.has(node)) {\n        const id = reflected.get(node); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n        reflected.delete(node);\n        registry.delete(id);\n        emit(node, {\n            payload: null,\n            name: id,\n            bubble: false,\n            origin: node,\n        });\n    }\n}\n/**\n * Get a node by a particular id.\n * @param node - Get a node by a given id\n * @public\n */\nfunction getNode$1(id) {\n    return registry.get(id);\n}\n/**\n * Reset the entire registry.\n * @public\n */\nfunction resetRegistry() {\n    registry.forEach((node) => {\n        deregister(node);\n    });\n    receipts.forEach((receipt) => emit.off(receipt));\n}\n/**\n *\n * @param id - An id to watch\n * @param callback - A callback to notify when the node is set or removed.\n * @public\n */\nfunction watchRegistry(id, callback) {\n    // register a listener\n    receipts.push(emit.on(id, callback));\n}\n\n/**\n * Applies a given config change to the node.\n * @param node - The node to check for config change\n * @param prop - Checks if this property exists in the local config or props\n * @param value - The value to set\n * @internal\n */\nfunction configChange(node, prop, value) {\n    // When we return false, node.walk will not continue into that child.\n    let usingFallback = true;\n    !(prop in node.config._t)\n        ? node.emit(`config:${prop}`, value, false)\n        : (usingFallback = false);\n    if (!(prop in node.props)) {\n        node.emit('prop', { prop, value });\n        node.emit(`prop:${prop}`, value);\n    }\n    return usingFallback;\n}\n/**\n * Creates a new instance of a global configuration option. This object is\n * essentially just a FormKitOption object, but it can be used as the root for\n * FormKitConfig's proxy and retain event \"emitting\".\n *\n * @param options - FormKit node options to be used globally.\n * @public\n */\nfunction createConfig$1(options = {}) {\n    const nodes = new Set();\n    const target = {\n        ...options,\n        ...{\n            _add: (node) => nodes.add(node),\n            _rm: (node) => node.remove(node),\n        },\n    };\n    const rootConfig = new Proxy(target, {\n        set(t, prop, value, r) {\n            if (typeof prop === 'string') {\n                nodes.forEach((node) => configChange(node, prop, value));\n            }\n            return Reflect.set(t, prop, value, r);\n        },\n    });\n    return rootConfig;\n}\n\n/**\n * Submits a FormKit form programmatically.\n * @param id - The id of the form\n * @public\n */\nfunction submitForm(id) {\n    const formElement = document.getElementById(id);\n    if (formElement instanceof HTMLFormElement) {\n        const event = new Event('submit', { cancelable: true, bubbles: true });\n        formElement.dispatchEvent(event);\n        return;\n    }\n    warn(151, id);\n}\n\n/**\n * Clear all state and error messages.\n */\nfunction clearState(node) {\n    const clear = (n) => {\n        for (const key in n.store) {\n            const message = n.store[key];\n            if (message.type === 'error' ||\n                (message.type === 'ui' && key === 'incomplete')) {\n                n.store.remove(key);\n            }\n            else if (message.type === 'state') {\n                n.store.set({ ...message, value: false });\n            }\n        }\n    };\n    clear(node);\n    node.walk(clear);\n}\n/**\n * Resets an input to it\u2019s \"initial\" value \u2014 if the input is a group or list it\n * resets all the children as well.\n * @param id - The id of an input to reset\n * @returns\n * @public\n */\nfunction reset(id, resetTo) {\n    const node = typeof id === 'string' ? getNode$1(id) : id;\n    if (node) {\n        const initial = (n) => cloneAny(n.props.initial) ||\n            (n.type === 'group' ? {} : n.type === 'list' ? [] : undefined);\n        // pause all events in this tree.\n        node._e.pause(node);\n        // Set it back to basics\n        node.input(cloneAny(resetTo) || initial(node), false);\n        // Set children back to basics in case they were additive (had their own value for example)\n        node.walk((child) => child.input(initial(child), false));\n        // Finally we need to lay any values back on top (if it is a group/list) since group values\n        // take precedence over child values.\n        const finalInit = initial(node);\n        node.input(typeof finalInit === 'object'\n            ? cloneAny(resetTo) || init(finalInit)\n            : finalInit, false);\n        // release the events.\n        node._e.play(node);\n        clearState(node);\n        return node;\n    }\n    warn(152, id);\n    return;\n}\n\n/**\n * Default configuration options.\n */\nconst defaultConfig = {\n    delimiter: '.',\n    delay: 0,\n    locale: 'en',\n    rootClasses: (key) => ({ [`formkit-${kebab(key)}`]: true }),\n};\n/**\n * If a node\u2019s name is set to useIndex, it replaces the node\u2019s name with the\n * index of the node relative to its parent\u2019s children.\n * @public\n */\nconst useIndex = Symbol('index');\n/**\n * When propagating values up a tree, this value indicates the child should be\n * removed.\n * @public\n */\nconst valueRemoved = Symbol('removed');\n/**\n * When propagating values up a tree, this value indicates the child should be\n * moved.\n * @public\n */\nconst valueMoved = Symbol('moved');\n/**\n * A simple type guard to determine if the context being evaluated is a list\n * type.\n * @param arg -\n * @returns arg is FormKitListContext\n * @public\n */\nfunction isList(arg) {\n    return arg.type === 'list' && Array.isArray(arg._value);\n}\n/**\n * Determine if a given object is a node\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction isNode(node) {\n    return node && typeof node === 'object' && node.__FKNode__ === true;\n}\n/**\n * The setter you are trying to access is invalid.\n */\nconst invalidSetter = (node, _context, property) => {\n    error(102, [node, property]);\n};\nconst traps = {\n    _c: trap(getContext, invalidSetter, false),\n    add: trap(addChild),\n    address: trap(getAddress, invalidSetter, false),\n    at: trap(getNode),\n    bubble: trap(bubble),\n    calm: trap(calm),\n    config: trap(false),\n    define: trap(define),\n    disturb: trap(disturb),\n    destroy: trap(destroy),\n    hydrate: trap(hydrate),\n    index: trap(getIndex, setIndex, false),\n    input: trap(input),\n    each: trap(eachChild),\n    emit: trap(emit$1),\n    find: trap(find),\n    on: trap(on),\n    off: trap(off),\n    parent: trap(false, setParent),\n    plugins: trap(false),\n    remove: trap(removeChild),\n    root: trap(getRoot, invalidSetter, false),\n    reset: trap(resetValue),\n    resetConfig: trap(resetConfig),\n    setErrors: trap(errors),\n    submit: trap(submit),\n    t: trap(text),\n    use: trap(use),\n    name: trap(getName, false, false),\n    walk: trap(walkTree),\n};\n/**\n * These are all the available \"traps\" for a given node. You can think of these\n * a little bit like methods, but they are really Proxy interceptors.\n */\nfunction createTraps() {\n    return new Map(Object.entries(traps));\n}\n/**\n * Creates a getter/setter trap and curries the context/node pair\n * @param getter - The getter function\n * @param setter - The setter function\n * @param curryGetter - Indicates if the getter should be curried or not\n * @returns\n */\nfunction trap(getter, setter, curryGetter = true) {\n    return {\n        get: getter\n            ? (node, context) => curryGetter\n                ? (...args) => getter(node, context, ...args)\n                : getter(node, context)\n            : false,\n        set: setter !== undefined ? setter : invalidSetter.bind(null),\n    };\n}\n/**\n * Create all of the node's hook dispatchers.\n */\nfunction createHooks() {\n    const hooks = new Map();\n    return new Proxy(hooks, {\n        get(_, property) {\n            if (!hooks.has(property)) {\n                hooks.set(property, createDispatcher());\n            }\n            return hooks.get(property);\n        },\n    });\n}\n/**\n * This is a simple integer counter of every createName() where the name needs\n * to be generated.\n */\nlet nameCount = 0;\n/**\n * This is a simple integer counter of every default id created.\n */\nlet idCount = 0;\n/**\n * Reports the global number of node registrations, useful for deterministic\n * node naming.\n * @public\n */\nfunction resetCount() {\n    nameCount = 0;\n    idCount = 0;\n}\n/**\n * Create a name based dictionary of all children in an array.\n * @param children -\n * @public\n */\nfunction names(children) {\n    return children.reduce((named, child) => Object.assign(named, { [child.name]: child }), {});\n}\n/**\n * This node is responsible for deterministically generating an id for this\n * node. This cannot just be a random id, it _must_ be deterministic to ensure\n * re-hydration of the form (like post-SSR) produces the same names/ids.\n *\n * @param options -\n * @returns string\n */\nfunction createName(options) {\n    var _a, _b;\n    if (((_a = options.parent) === null || _a === void 0 ? void 0 : _a.type) === 'list')\n        return useIndex;\n    return options.name || `${((_b = options.props) === null || _b === void 0 ? void 0 : _b.type) || 'input'}_${++nameCount}`;\n}\n/**\n * Creates the initial value for a node based on the options passed in and the\n * type of the input.\n * @param options -\n * @param type -\n * @returns\n * @internal\n */\nfunction createValue(options) {\n    if (options.type === 'group') {\n        return init(options.value &&\n            typeof options.value === 'object' &&\n            !Array.isArray(options.value)\n            ? options.value\n            : {});\n    }\n    else if (options.type === 'list') {\n        return init(Array.isArray(options.value) ? options.value : []);\n    }\n    return options.value === null ? '' : options.value;\n}\n/**\n * Sets the internal value of the node.\n * @param node -\n * @param context -\n * @param value -\n * @returns T\n */\nfunction input(node, context, value, async = true, eqBefore = true) {\n    if (eqBefore && eq(context._value, value))\n        return context.settled;\n    context._value = validateInput(node, node.hook.input.dispatch(value));\n    if (!eqBefore && eq(context._value, value))\n        return context.settled;\n    node.emit('input', context._value);\n    if (context.isSettled)\n        node.disturb();\n    if (async) {\n        if (context._tmo)\n            clearTimeout(context._tmo);\n        context._tmo = setTimeout(commit, node.props.delay, node, context);\n    }\n    else {\n        commit(node, context);\n    }\n    return context.settled;\n}\n/**\n * Validate that the current input is allowed.\n * @param type - The type of node (input, list, group)\n * @param value - The value that is being set\n */\nfunction validateInput(node, value) {\n    switch (node.type) {\n        // Inputs are allowed to have any type\n        case 'input':\n            break;\n        case 'group':\n            if (!value || typeof value !== 'object')\n                error(107, [node, value]);\n            break;\n        case 'list':\n            if (!Array.isArray(value))\n                error(108, [node, value]);\n            break;\n    }\n    return value;\n}\n/**\n * Commits the working value to the node graph as the value of this node.\n * @param node -\n * @param context -\n * @param calm -\n * @param hydrate -\n */\nfunction commit(node, context, calm = true, hydrate = true) {\n    if (node.type !== 'input' && hydrate)\n        node.hydrate();\n    context.value = node.hook.commit.dispatch(context._value);\n    node.emit('commit', context.value);\n    if (calm)\n        node.calm();\n}\n/**\n * Perform a modification to a single element of a parent aggregate value. This\n * is only performed on the pre-committed value (_value), although typically\n * the value and _value are both linked in memory.\n * @param context -\n * @param name -\n * @param value -\n */\nfunction partial(context, { name, value, from }) {\n    if (isList(context)) {\n        const insert = value === valueRemoved\n            ? []\n            : value === valueMoved\n                ? context._value.splice(from, 1) // eslint-disable-line @typescript-eslint/no-non-null-assertion\n                : [value];\n        context._value.splice(name, value === valueMoved ? 0 : 1, ...insert);\n        return;\n    }\n    // In this case we know for sure we're dealing with a group, TS doesn't\n    // know that however, so we use some unpleasant casting here\n    if (value !== valueRemoved) {\n        context._value[name] = value;\n    }\n    else {\n        delete context._value[name];\n    }\n}\n/**\n * Pass values down to children by calling hydrate on them.\n * @param parent -\n * @param child -\n */\nfunction hydrate(node, context) {\n    const _value = context._value;\n    context.children.forEach((child) => {\n        if (typeof _value !== 'object')\n            return;\n        // if (has(context._value as FormKitGroupValue, child.name)) {\n        if (child.name in _value) {\n            // In this case, the parent has a value to give to the child, so we\n            // perform a down-tree synchronous input which will cascade values down\n            // and then ultimately back up.\n            const childValue = child.type !== 'input' || typeof _value[child.name] === 'object'\n                ? init(_value[child.name])\n                : _value[child.name];\n            child.input(childValue, false);\n        }\n        else {\n            if (node.type !== 'list' || typeof child.name === 'number') {\n                // In this case, the parent\u2019s values have no knowledge of the child\n                // value \u2014 this typically occurs on the commit at the end of addChild()\n                // we need to create a value reservation for this node\u2019s name. This is\n                // especially important when dealing with lists where index matters.\n                partial(context, { name: child.name, value: child.value });\n            }\n            if (!_value.__init) {\n                // In this case, someone has explicitly set the value to an empty object\n                // with node.input({}) so we do not define the __init property:\n                if (child.type === 'group')\n                    child.input({}, false);\n                else if (child.type === 'list')\n                    child.input([], false);\n                else\n                    child.input(undefined, false);\n            }\n        }\n    });\n    return node;\n}\n/**\n * Disturbs the state of a node from settled to unsettled\u00A0\u2014 creating appropriate\n * promises and resolutions.\n * @param node -\n * @param context -\n */\nfunction disturb(node, context) {\n    var _a;\n    if (context._d <= 0) {\n        context.isSettled = false;\n        node.emit('settled', false, false);\n        context.settled = new Promise((resolve) => {\n            context._resolve = resolve;\n        });\n        if (node.parent)\n            (_a = node.parent) === null || _a === void 0 ? void 0 : _a.disturb();\n    }\n    context._d++;\n    return node;\n}\n/**\n * Calms the given node's disturbed state by one.\n * @param node -\n * @param context -\n */\nfunction calm(node, context, value) {\n    var _a;\n    if (value !== undefined && node.type !== 'input') {\n        partial(context, value);\n        // Commit the value up, but do not hydrate back down\n        return commit(node, context, true, false);\n    }\n    if (context._d > 0)\n        context._d--;\n    if (context._d === 0) {\n        context.isSettled = true;\n        node.emit('settled', true, false);\n        if (node.parent)\n            (_a = node.parent) === null || _a === void 0 ? void 0 : _a.calm({ name: node.name, value: context.value });\n        if (context._resolve)\n            context._resolve(context.value);\n    }\n}\n/**\n * This node is being removed and needs to be cleaned up.\n * @param node - The node to shut down\n * @param context - The context to clean up\n */\nfunction destroy(node) {\n    node.emit('destroying', node);\n    // flush all messages out\n    node.store.filter(() => false);\n    if (node.parent) {\n        node.parent.remove(node);\n    }\n    deregister(node);\n    node.emit('destroyed', node);\n}\n/**\n * Defines the current input type concretely.\n * @param definition - The definition of the current input type.\n */\nfunction define(node, context, definition) {\n    // Assign the type\n    context.type = definition.type;\n    // Assign the definition\n    context.props.definition = definition;\n    // Ensure the type is seeded with the `__init` value.\n    context.value = context._value = createValue({\n        type: node.type,\n        value: context.value,\n    });\n    // Apply any input features before resetting the props.\n    if (definition.features) {\n        definition.features.forEach((feature) => feature(node));\n    }\n    // Its possible that input-defined \"props\" have ended up in the context attrs\n    // these should be moved back out of the attrs object.\n    if (definition.props) {\n        if (node.props.attrs) {\n            const attrs = { ...node.props.attrs };\n            // Temporarily disable prop emits\n            node.props._emit = false;\n            for (const attr in attrs) {\n                const camelName = camel(attr);\n                if (definition.props.includes(camelName)) {\n                    node.props[camelName] = attrs[attr];\n                    delete attrs[attr];\n                }\n            }\n            const initial = cloneAny(context._value);\n            node.props.initial =\n                node.type !== 'input' ? init(initial) : initial;\n            // Re-enable prop emits\n            node.props._emit = true;\n            node.props.attrs = attrs;\n        }\n    }\n    node.emit('defined', definition);\n}\n/**\n * (node.add) Adds a child to the node.\n * @param context -\n * @param node -\n * @param child -\n */\nfunction addChild(parent, parentContext, child) {\n    if (parent.type === 'input')\n        error(100, parent);\n    if (child.parent && child.parent !== parent) {\n        child.parent.remove(child);\n    }\n    // Synchronously set the initial value on the parent\n    if (!parentContext.children.includes(child)) {\n        parentContext.children.push(child);\n        if (!child.isSettled)\n            parent.disturb();\n    }\n    if (child.parent !== parent) {\n        child.parent = parent;\n        // In this edge case middleware changed the parent assignment so we need to\n        // re-add the child\n        if (child.parent !== parent) {\n            parent.remove(child);\n            child.parent.add(child);\n            return parent;\n        }\n    }\n    else {\n        // When a parent is properly assigned, we inject the parent's plugins on the\n        // child.\n        child.use(parent.plugins);\n    }\n    // Finally we call commit here, which sub-calls hydrate(), hydrate() will\n    // resolve any conflict between the parent and child values, and also ensure\n    // proper \"placeholders\" are made on the parent.\n    commit(parent, parentContext, false);\n    parent.ledger.merge(child);\n    parent.emit('child', child);\n    return parent;\n}\n/**\n * The setter for node.parent = FormKitNode\n * @param _context -\n * @param node -\n * @param _property -\n * @param parent -\n * @returns boolean\n */\nfunction setParent(child, context, _property, parent) {\n    if (isNode(parent)) {\n        if (child.parent && child.parent !== parent) {\n            child.parent.remove(child);\n        }\n        context.parent = parent;\n        child.resetConfig();\n        !parent.children.includes(child)\n            ? parent.add(child)\n            : child.use(parent.plugins);\n        return true;\n    }\n    if (parent === null) {\n        context.parent = null;\n        return true;\n    }\n    return false;\n}\n/**\n * (node.remove) Removes a child from the node.\n * @param context -\n * @param node -\n * @param child -\n */\nfunction removeChild(node, context, child) {\n    const childIndex = context.children.indexOf(child);\n    if (childIndex !== -1) {\n        if (child.isSettled)\n            node.disturb();\n        context.children.splice(childIndex, 1);\n        // If an ancestor uses the preserve prop, then we are expected to not remove\n        // our values on this node either, see #53\n        let preserve = undefine(child.props.preserve);\n        let parent = child.parent;\n        while (preserve === undefined && parent) {\n            preserve = undefine(parent.props.preserve);\n            parent = parent.parent;\n        }\n        if (!preserve) {\n            node.calm({\n                name: node.type === 'list' ? childIndex : child.name,\n                value: valueRemoved,\n            });\n        }\n        child.parent = null;\n        // Remove the child from the config. Is this weird? Yes. Is it ok? Yes.\n        child.config._rmn = child;\n    }\n    node.ledger.unmerge(child);\n    return node;\n}\n/**\n * Iterate over each immediate child and perform a callback.\n * @param context -\n * @param _node -\n * @param callback -\n */\nfunction eachChild(_node, context, callback) {\n    context.children.forEach((child) => callback(child));\n}\n/**\n * Walk all nodes below this one and execute a callback.\n * @param _node -\n * @param context -\n * @param callback -\n */\nfunction walkTree(_node, context, callback, stopIfFalse = false) {\n    context.children.forEach((child) => {\n        if (callback(child) !== false || !stopIfFalse) {\n            child.walk(callback);\n        }\n    });\n}\n/**\n * Set the configuration options of the node and it's subtree.\n * @param node -\n * @param context -\n * @param _property -\n * @param config -\n */\nfunction resetConfig(node, context) {\n    const parent = node.parent || undefined;\n    context.config = createConfig(node.config._t, parent);\n    node.walk((n) => n.resetConfig());\n}\n/**\n * Adds a plugin to the node, it\u2019s children, and executes it.\n * @param context -\n * @param node -\n * @param plugin -\n * @public\n */\nfunction use(node, context, plugin, run = true, library = true) {\n    if (Array.isArray(plugin) || plugin instanceof Set) {\n        plugin.forEach((p) => use(node, context, p));\n        return node;\n    }\n    if (!context.plugins.has(plugin)) {\n        if (library && typeof plugin.library === 'function')\n            plugin.library(node);\n        // When plugins return false, they are never added as to the plugins Set\n        // meaning they only ever have access to the single node they were added on.\n        if (run && plugin(node) !== false) {\n            context.plugins.add(plugin);\n            node.children.forEach((child) => child.use(plugin));\n        }\n    }\n    return node;\n}\n/**\n * Moves a node in the parent\u2019s children to the given index.\n * @param node -\n * @param _context -\n * @param _property -\n * @param setIndex -\n */\nfunction setIndex(node, _context, _property, setIndex) {\n    if (isNode(node.parent)) {\n        const children = node.parent.children;\n        const index = setIndex >= children.length\n            ? children.length - 1\n            : setIndex < 0\n                ? 0\n                : setIndex;\n        const oldIndex = children.indexOf(node);\n        if (oldIndex === -1)\n            return false;\n        children.splice(oldIndex, 1);\n        children.splice(index, 0, node);\n        node.parent.children = children;\n        if (node.parent.type === 'list')\n            node.parent\n                .disturb()\n                .calm({ name: index, value: valueMoved, from: oldIndex });\n        return true;\n    }\n    return false;\n}\n/**\n * Retrieves the index of a node from the parent\u2019s children.\n * @param node -\n */\nfunction getIndex(node) {\n    if (node.parent) {\n        const index = [...node.parent.children].indexOf(node);\n        // If the index is currently -1 then the node isnt finished booting, so it\n        // must be the next node.\n        return index === -1 ? node.parent.children.length : index;\n    }\n    return -1;\n}\n/**\n * Retrieves the context object of a given node. This is intended to be a\n * private trap and should absolutely not be used in plugins or user-land code.\n * @param _node -\n * @param context -\n */\nfunction getContext(_node, context) {\n    return context;\n}\n/**\n * Get the name of the current node, allowing for slight mutations.\n * @param node -\n * @param context -\n */\nfunction getName(node, context) {\n    var _a;\n    if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === 'list')\n        return node.index;\n    return context.name !== useIndex ? context.name : node.index;\n}\n/**\n * Returns the address of the current node.\n * @param node -\n * @param context -\n */\nfunction getAddress(node, context) {\n    return context.parent\n        ? context.parent.address.concat([node.name])\n        : [node.name];\n}\n/**\n * Fetches a node from the tree by its address.\n * @param context -\n * @param node -\n * @param location -\n * @returns FormKitNode\n */\nfunction getNode(node, _context, locator) {\n    const address = typeof locator === 'string' ? locator.split(node.config.delimiter) : locator;\n    if (!address.length)\n        return undefined;\n    const first = address[0];\n    let pointer = node.parent;\n    if (!pointer) {\n        // This address names the root node, remove it to get child name:\n        if (String(address[0]) === String(node.name))\n            address.shift();\n        // All root nodes start at themselves ultimately:\n        pointer = node;\n    }\n    // Any addresses starting with $parent should discard it\n    if (first === '$parent')\n        address.shift();\n    while (pointer && address.length) {\n        const name = address.shift();\n        switch (name) {\n            case '$root':\n                pointer = node.root;\n                break;\n            case '$parent':\n                pointer = pointer.parent;\n                break;\n            case '$self':\n                pointer = node;\n                break;\n            default:\n                pointer =\n                    pointer.children.find((c) => String(c.name) === String(name)) ||\n                        select(pointer, name);\n        }\n    }\n    return pointer || undefined;\n}\n/**\n * Perform selections on a subtree using the address \"selector\" methods.\n * @param node -\n * @param selector -\n * @returns FormKitNode | undefined\n */\nfunction select(node, selector) {\n    const matches = String(selector).match(/^(find)\\((.*)\\)$/);\n    if (matches) {\n        const [, action, argStr] = matches;\n        const args = argStr.split(',').map((arg) => arg.trim());\n        switch (action) {\n            case 'find':\n                return node.find(args[0], args[1]);\n            default:\n                return undefined;\n        }\n    }\n    return undefined;\n}\n/**\n * Perform a breadth first search and return the first instance of a node that\n * is found in the subtree or undefined.\n * @param node - The node to start the search on/under\n * @param _context - The context object\n * @param searchTerm - The term we are searching for\n * @param searcher - Either a key to search on, or a function\n * @returns\n */\nfunction find(node, _context, searchTerm, searcher) {\n    return bfs(node, searchTerm, searcher);\n}\n/**\n * Perform a breadth-first-search on a node subtree and locate the first\n * instance of a match.\n * @param node -\n * @param name -\n * @returns FormKitNode\n * @public\n */\nfunction bfs(tree, searchValue, searchGoal = 'name') {\n    const search = typeof searchGoal === 'string'\n        ? (n) => n[searchGoal] == searchValue // non-strict comparison is intentional\n        : searchGoal;\n    const stack = [tree];\n    while (stack.length) {\n        const node = stack.shift(); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n        if (search(node, searchValue))\n            return node;\n        stack.push(...node.children);\n    }\n    return undefined;\n}\n/**\n * Get the root node of the tree.\n */\nfunction getRoot(n) {\n    let node = n;\n    while (node.parent) {\n        node = node.parent;\n    }\n    return node;\n}\n/**\n * Creates a new configuration option.\n * @param parent -\n * @param configOptions -\n * @returns FormKitConfig\n */\nfunction createConfig(target = {}, parent) {\n    let node = undefined;\n    return new Proxy(target, {\n        get(...args) {\n            const prop = args[1];\n            if (prop === '_t')\n                return target;\n            const localValue = Reflect.get(...args);\n            // Check our local values first\n            if (localValue !== undefined)\n                return localValue;\n            // Then check our parent values next\n            if (parent) {\n                const parentVal = parent.config[prop];\n                if (parentVal !== undefined)\n                    return parentVal;\n            }\n            if (target.rootConfig && typeof prop === 'string') {\n                const rootValue = target.rootConfig[prop];\n                if (rootValue !== undefined)\n                    return rootValue;\n            }\n            // The default delay value should be 20\n            if (prop === 'delay' && (node === null || node === void 0 ? void 0 : node.type) === 'input')\n                return 20;\n            // Finally check the default values\n            return defaultConfig[prop];\n        },\n        set(...args) {\n            const prop = args[1];\n            const value = args[2];\n            if (prop === '_n') {\n                node = value;\n                if (target.rootConfig)\n                    target.rootConfig._add(node);\n                return true;\n            }\n            if (prop === '_rmn') {\n                if (target.rootConfig)\n                    target.rootConfig._rm(node);\n                node = undefined;\n                return true;\n            }\n            if (!eq(target[prop], value, false)) {\n                const didSet = Reflect.set(...args);\n                if (node) {\n                    node.emit(`config:${prop}`, value, false);\n                    configChange(node, prop, value);\n                    // Walk the node tree and notify of config/prop changes where relevant\n                    node.walk((n) => configChange(n, prop, value), true);\n                }\n                return didSet;\n            }\n            return true;\n        },\n    });\n}\n/**\n * Given a string of text, expose it for modification, translation, or full\n * replacement.\n * @param key - A message key, or generic string of text\n * @returns\n */\nfunction text(node, _context, key, type = 'ui') {\n    const fragment = typeof key === 'string' ? { key, value: key, type } : key;\n    const value = node.hook.text.dispatch(fragment);\n    node.emit('text', value, false);\n    return value.value;\n}\n/**\n * Submits the nearest ancestor that is a FormKit \"form\". It determines which\n * node is a form by locating an ancestor where node.props.isForm = true.\n * @param node - The node to initiate the submit\n */\nfunction submit(node) {\n    const name = node.name;\n    do {\n        if (node.props.isForm === true)\n            break;\n        if (!node.parent)\n            error(106, name);\n        node = node.parent;\n    } while (node);\n    if (node.props.id) {\n        submitForm(node.props.id);\n    }\n}\n/**\n * Reset to the original value.\n * @param node - The node to reset\n * @param _context - The context\n * @param value - The value to reset to\n */\nfunction resetValue(node, _context, value) {\n    return reset(node, value);\n}\n/**\n * Sets errors on the node and optionally its children.\n * @param node - The node to set errors on\n * @param _context - Not used\n * @param localErrors - An array of errors to set on this node\n * @param childErrors - An object of name to errors to set on children.\n */\nfunction errors(node, _context, localErrors, childErrors) {\n    const sourceKey = `${node.name}-set`;\n    createMessages(node, localErrors, childErrors).forEach((errors) => {\n        node.store.apply(errors, (message) => message.meta.source === sourceKey);\n    });\n}\n/**\n * Middleware to assign default prop values as issued by core.\n * @param node - The node being registered\n * @param next - Calls the next middleware.\n * @returns\n */\nfunction defaultProps(node) {\n    if (!has(node.props, 'id'))\n        node.props.id = `input_${idCount++}`;\n    return node;\n}\n/**\n * @param options -\n * @param config -\n */\nfunction createProps(initial) {\n    const props = {\n        initial: typeof initial === 'object' ? cloneAny(initial) : initial,\n    };\n    let node;\n    let isEmitting = true;\n    return new Proxy(props, {\n        get(...args) {\n            const [_t, prop] = args;\n            if (has(props, prop))\n                return Reflect.get(...args);\n            if (node && typeof prop === 'string' && node.config[prop] !== undefined)\n                return node.config[prop];\n            return undefined;\n        },\n        set(target, property, originalValue, receiver) {\n            if (property === '_n') {\n                node = originalValue;\n                return true;\n            }\n            if (property === '_emit') {\n                isEmitting = originalValue;\n                return true;\n            }\n            const { prop, value } = node.hook.prop.dispatch({\n                prop: property,\n                value: originalValue,\n            });\n            // Typescript compiler cannot handle a symbol index, even though js can:\n            if (!eq(props[prop], value, false)) {\n                const didSet = Reflect.set(target, prop, value, receiver);\n                if (isEmitting) {\n                    node.emit('prop', { prop, value });\n                    if (typeof prop === 'string')\n                        node.emit(`prop:${prop}`, value);\n                }\n                return didSet;\n            }\n            return true;\n        },\n    });\n}\n/**\n * A cheap function that iterates over all plugins and stops once node.define\n * is called.\n * @param node - A formkit node\n * @param plugins - An array of plugins\n * @returns\n */\nfunction findDefinition(node, plugins) {\n    // If the definition is already there, force call to define.\n    if (node.props.definition)\n        return node.define(node.props.definition);\n    for (const plugin of plugins) {\n        if (node.props.definition)\n            return;\n        if (typeof plugin.library === 'function') {\n            plugin.library(node);\n        }\n    }\n}\n/**\n * Create a new context object for our a FormKit node, given default information\n * @param options - An options object to override the defaults.\n * @returns FormKitContext\n */\nfunction createContext(options) {\n    const value = createValue(options);\n    const config = createConfig(options.config || {}, options.parent);\n    return {\n        _d: 0,\n        _e: createEmitter(),\n        _resolve: false,\n        _tmo: false,\n        _value: value,\n        children: dedupe(options.children || []),\n        config,\n        hook: createHooks(),\n        isCreated: false,\n        isSettled: true,\n        ledger: createLedger(),\n        name: createName(options),\n        parent: options.parent || null,\n        plugins: new Set(),\n        props: createProps(value),\n        settled: Promise.resolve(value),\n        store: createStore(true),\n        traps: createTraps(),\n        type: options.type || 'input',\n        value,\n    };\n}\n/**\n * Initialize a node object's internal properties.\n * @param node - The node to initialize\n * @returns FormKitNode\n */\nfunction nodeInit(node, options) {\n    var _a;\n    // Set the internal node on the props, config, ledger and store\n    node.ledger.init((node.store._n = node.props._n = node.config._n = node));\n    // Apply given in options to the node.\n    node.props._emit = false;\n    if (options.props)\n        Object.assign(node.props, options.props);\n    node.props._emit = true;\n    // Attempt to find a definition from the pre-existing plugins.\n    findDefinition(node, new Set([\n        ...(options.plugins || []),\n        ...(node.parent ? node.parent.plugins : []),\n    ]));\n    // Then we apply each plugin's root code, we do this with an explicit loop\n    // for that ity-bitty performance bump.\n    if (options.plugins) {\n        for (const plugin of options.plugins) {\n            use(node, node._c, plugin, true, false);\n        }\n    }\n    // Initialize the default props\n    defaultProps(node);\n    // Apply the parent to each child.\n    node.each((child) => node.add(child));\n    // If the node has a parent, ensure it's properly nested bi-directionally.\n    if (node.parent)\n        node.parent.add(node);\n    // Inputs are leafs, and cannot have children\n    if (node.type === 'input' && node.children.length)\n        error(100, node);\n    // Apply the input hook to the initial value.\n    input(node, node._c, node._value, false, false);\n    // Release the store buffer\n    node.store.release();\n    // Register the node globally if someone explicitly gave it an id\n    if ((_a = options.props) === null || _a === void 0 ? void 0 : _a.id)\n        register(node);\n    // Our node is finally ready, emit it to the world\n    node.emit('created', node);\n    node.isCreated = true;\n    return node;\n}\n/**\n * Creates a new instance of a FormKit Node. Nodes are the atomic unit of\n * a FormKit graph.\n *\n * @param options - An object of options to define the node.\n * @returns FormKitNode\n * @public\n */\nfunction createNode(options) {\n    const ops = options || {};\n    const context = createContext(ops);\n    // Note: The typing for the proxy object cannot be fully modeled, thus we are\n    // force-typing to a FormKitNode. See:\n    // https://github.com/microsoft/TypeScript/issues/28067\n    const node = new Proxy(context, {\n        get(...args) {\n            const [, property] = args;\n            if (property === '__FKNode__')\n                return true;\n            const trap = context.traps.get(property);\n            if (trap && trap.get)\n                return trap.get(node, context);\n            return Reflect.get(...args);\n        },\n        set(...args) {\n            const [, property, value] = args;\n            const trap = context.traps.get(property);\n            if (trap && trap.set)\n                return trap.set(node, context, property, value);\n            return Reflect.set(...args);\n        },\n    });\n    return nodeInit(node, ops);\n}\n\n/**\n * Type narrow that a node is a DOM node.\n * @param node - A schema node to check\n * @returns\n * @public\n */\nfunction isDOM(node) {\n    return typeof node !== 'string' && has(node, '$el');\n}\n/**\n * Type narrow that a node is a DOM node.\n * @param node - A schema node to check\n * @returns\n * @public\n */\nfunction isComponent(node) {\n    return typeof node !== 'string' && has(node, '$cmp');\n}\n/**\n * Root declaration.\n * @param node - An object to check\n * @returns\n * @public\n */\nfunction isConditional(node) {\n    if (!node || typeof node === 'string')\n        return false;\n    return has(node, 'if') && has(node, 'then');\n}\n/**\n * Determines if the node is syntactic sugar or not.\n * @param node - Node\n * @returns\n * @public\n */\nfunction isSugar(node) {\n    return typeof node !== 'string' && '$formkit' in node;\n}\n/**\n * Converts syntactic sugar nodes to standard nodes.\n * @param node - A node to covert\n * @returns\n * @public\n */\nfunction sugar(node) {\n    if (typeof node === 'string') {\n        return {\n            $el: 'text',\n            children: node,\n        };\n    }\n    if (isSugar(node)) {\n        const { $formkit: type, for: iterator, if: condition, children, key, bind, ...props } = node;\n        return Object.assign({\n            $cmp: 'FormKit',\n            props: { ...props, type },\n        }, condition ? { if: condition } : {}, iterator ? { for: iterator } : {}, children ? { children } : {}, key ? { key } : {}, bind ? { bind } : {});\n    }\n    return node;\n}\n\n/**\n * Compiles a logical string like \"a != z || b == c\" into a single function.\n * The return value is an object with a \"provide\" method that iterates over all\n * requirement tokens to use as replacements.\n * ```typescript\n * let name = {\n *   value: 'jon'\n * }\n * const condition = compile(\"$name == 'bob'\").provide((token) => {\n *  return () => name.value // must return a function!\n * })\n *\n * condition() // false\n * ```\n * @param expr - A string to compile\n * @returns\n * @public\n */\nfunction compile(expr) {\n    /**\n     * These tokens are replacements used in evaluating a given condition.\n     */\n    // const tokens: FormKitTokens = {}\n    /**\n     * The value of the provide() callback. Used for late binding.\n     */\n    let provideTokens;\n    /**\n     * These are token requirements like \"$name.value\" that are need to fulfill\n     * a given condition call.\n     */\n    const requirements = new Set();\n    /**\n     * Expands the current value if it is a function.\n     * @param operand - A left or right hand operand\n     * @returns\n     */\n    const x = function expand(operand, tokens) {\n        return typeof operand === 'function' ? operand(tokens) : operand;\n    };\n    /**\n     * Comprehensive list of operators. This list MUST be\n     * ordered by the length of the operator characters in descending order.\n     */\n    const operatorRegistry = [\n        {\n            '&&': (l, r, t) => x(l, t) && x(r, t),\n            '||': (l, r, t) => x(l, t) || x(r, t),\n        },\n        {\n            '===': (l, r, t) => !!(x(l, t) === x(r, t)),\n            '!==': (l, r, t) => !!(x(l, t) !== x(r, t)),\n            '==': (l, r, t) => !!(x(l, t) == x(r, t)),\n            '!=': (l, r, t) => !!(x(l, t) != x(r, t)),\n            '>=': (l, r, t) => !!(x(l, t) >= x(r, t)),\n            '<=': (l, r, t) => !!(x(l, t) <= x(r, t)),\n            '>': (l, r, t) => !!(x(l, t) > x(r, t)),\n            '<': (l, r, t) => !!(x(l, t) < x(r, t)),\n        },\n        {\n            '+': (l, r, t) => x(l, t) + x(r, t),\n            '-': (l, r, t) => x(l, t) - x(r, t),\n        },\n        {\n            '*': (l, r, t) => x(l, t) * x(r, t),\n            '/': (l, r, t) => x(l, t) / x(r, t),\n            '%': (l, r, t) => x(l, t) % x(r, t),\n        },\n    ];\n    /**\n     * A full list of all operator symbols.\n     */\n    const operatorSymbols = operatorRegistry.reduce((s, g) => {\n        return s.concat(Object.keys(g));\n    }, []);\n    /**\n     * An array of the first character of each operator.\n     */\n    const operatorChars = new Set(operatorSymbols.map((key) => key.charAt(0)));\n    /**\n     * Determines if the current character is the start of an operator symbol, if it\n     * is, it returns that symbol.\n     * @param symbols - An array of symbols that are considered operators\n     * @param char - The current character being operated on\n     * @param p - The position of the pointer\n     * @param expression - The full string expression\n     * @returns\n     */\n    function getOp(symbols, char, p, expression) {\n        const candidates = symbols.filter((s) => s.startsWith(char));\n        if (!candidates.length)\n            return false;\n        return candidates.find((symbol) => {\n            if (expression.length >= p + symbol.length) {\n                const nextChars = expression.substr(p, symbol.length);\n                if (nextChars === symbol)\n                    return symbol;\n            }\n            return false;\n        });\n    }\n    /**\n     * Determines the step number of the right or left hand operator.\n     * @param p - The position of the pointer\n     * @param expression - The full string expression\n     * @param direction - 1 = right, 0 = left\n     */\n    function getStep(p, expression, direction = 1) {\n        let next = direction\n            ? expression.substr(p + 1).trim()\n            : expression.substr(0, p).trim();\n        if (!next.length)\n            return -1;\n        if (!direction) {\n            // left hand direction could include a function name we need to remove\n            const reversed = next.split('').reverse();\n            const start = reversed.findIndex((char) => operatorChars.has(char));\n            next = reversed.slice(start).join('');\n        }\n        const char = next[0];\n        return operatorRegistry.findIndex((operators) => {\n            const symbols = Object.keys(operators);\n            return !!getOp(symbols, char, 0, next);\n        });\n    }\n    /**\n     * Extracts a tail call. For example:\n     * ```\n     * $foo().bar(baz) + 7\n     * ```\n     * Would extract \"bar(baz)\" and return p of 15 (after the (baz)).\n     *\n     * @param p - The position of a closing parenthetical.\n     * @param expression - The full expression being parsed.\n     */\n    function getTail(pos, expression) {\n        let tail = '';\n        const length = expression.length;\n        let depth = 0;\n        for (let p = pos; p < length; p++) {\n            const char = expression.charAt(p);\n            if (char === '(') {\n                depth++;\n            }\n            else if (char === ')') {\n                depth--;\n            }\n            else if (depth === 0 && char === ' ') {\n                continue;\n            }\n            if (depth === 0 && getOp(operatorSymbols, char, p, expression)) {\n                return [tail, p - 1];\n            }\n            else {\n                tail += char;\n            }\n        }\n        return [tail, expression.length - 1];\n    }\n    /**\n     * Parse a string expression into a function that returns a boolean. This is\n     * the magic behind schema logic like $if.\n     * @param expression - A string expression to parse\n     * @returns\n     */\n    function parseLogicals(expression, step = 0) {\n        const operators = operatorRegistry[step];\n        const length = expression.length;\n        const symbols = Object.keys(operators);\n        let depth = 0;\n        let quote = false;\n        let op = null;\n        let operand = '';\n        let left = null;\n        let operation;\n        let lastChar = '';\n        let char = '';\n        let parenthetical = '';\n        let startP = 0;\n        const addTo = (depth, char) => {\n            depth ? (parenthetical += char) : (operand += char);\n        };\n        for (let p = 0; p < length; p++) {\n            lastChar = char;\n            char = expression.charAt(p);\n            if (!quote &&\n                (char === \"'\" || char === '\"') &&\n                lastChar !== '\\\\' &&\n                depth === 0) {\n                quote = char;\n                addTo(depth, char);\n                continue;\n            }\n            else if (quote && (char !== quote || lastChar === '\\\\')) {\n                addTo(depth, char);\n                continue;\n            }\n            else if (quote === char) {\n                quote = false;\n                addTo(depth, char);\n                continue;\n            }\n            else if (char === ' ') {\n                continue;\n            }\n            else if (char === '(') {\n                if (depth === 0) {\n                    startP = p;\n                }\n                else {\n                    parenthetical += char;\n                }\n                depth++;\n            }\n            else if (char === ')') {\n                depth--;\n                if (depth === 0) {\n                    // Parenthetical statements cannot be grouped up in the implicit order\n                    // of left/right statements based on which step they are on because\n                    // they are parsed on every step and then must be applied to the\n                    // operator. Example:\n                    //\n                    // 5 + (3) * 2\n                    //\n                    // This should yield 11 not 16. This order is normally implicit in the\n                    // sequence of operators being parsed, but with parenthesis the parse\n                    // happens each time. Instead we need to know if the resulting value\n                    // should be applied to the left or the right hand operator. The\n                    // general algorithm is:\n                    //\n                    // 1. Does this paren have an operator on the left or right side\n                    // 2. If not, it's unnecessarily wrapped (3 + 2)\n                    // 3. If it does, then which order of operation is highest?\n                    // 4. Wait for the highest order of operation to bind to an operator.\n                    // If the parenthetical has a preceding token like $fn(1 + 2) then we\n                    // need to subtract the existing operand length from the start\n                    // to determine if this is a left or right operation\n                    const fn = typeof operand === 'string' && operand.startsWith('$')\n                        ? operand\n                        : undefined;\n                    const hasTail = fn && expression.charAt(p + 1) === '.';\n                    // It's possible the function has a chained tail call:\n                    let tail = '';\n                    if (hasTail) {\n                        [tail, p] = getTail(p + 2, expression);\n                    }\n                    const lStep = op ? step : getStep(startP, expression, 0);\n                    const rStep = getStep(p, expression);\n                    if (lStep === -1 && rStep === -1) {\n                        // This parenthetical was unnecessarily wrapped at the root\n                        operand = evaluate(parenthetical, -1, fn, tail);\n                    }\n                    else if (op && (lStep >= rStep || rStep === -1) && step === lStep) {\n                        // has a left hand operator with a higher order of operation\n                        left = op.bind(null, evaluate(parenthetical, -1, fn, tail));\n                        op = null;\n                        operand = '';\n                    }\n                    else if (rStep > lStep && step === rStep) {\n                        // should be applied to the right hand operator when it gets one\n                        operand = evaluate(parenthetical, -1, fn, tail);\n                    }\n                    else {\n                        operand += `(${parenthetical})${hasTail ? `.${tail}` : ''}`;\n                    }\n                    parenthetical = '';\n                }\n                else {\n                    parenthetical += char;\n                }\n            }\n            else if (depth === 0 &&\n                (operation = getOp(symbols, char, p, expression))) {\n                if (p === 0) {\n                    error(103, [operation, expression]);\n                }\n                // We identified the operator by looking ahead in the string, so we need\n                // our position to move past the operator\n                p += operation.length - 1;\n                if (p === expression.length - 1) {\n                    error(104, [operation, expression]);\n                }\n                if (!op) {\n                    // Bind the left hand operand\n                    if (left) {\n                        // In this case we've already parsed the left hand operator\n                        op = operators[operation].bind(null, evaluate(left, step));\n                        left = null;\n                    }\n                    else {\n                        op = operators[operation].bind(null, evaluate(operand, step));\n                        operand = '';\n                    }\n                }\n                else if (operand) {\n                    // Bind the right hand operand, and return the resulting expression as a new left hand operator\n                    left = op.bind(null, evaluate(operand, step));\n                    op = operators[operation].bind(null, left);\n                    operand = '';\n                }\n                continue;\n            }\n            else {\n                addTo(depth, char);\n            }\n        }\n        if (operand && op) {\n            // If we were left with an operand after the loop, and an op, it should\n            // be the right hand assignment.\n            op = op.bind(null, evaluate(operand, step));\n        }\n        // If we don't have an op, but we do have a left hand assignment, then that\n        // is actually our operator, so just re-assign it to op\n        op = !op && left ? left : op;\n        if (!op && operand) {\n            // If we don't have any op but we do have an operand so there is no boolean\n            // logic to perform, but that operand still means something so we need to\n            // evaluate it and return it as a function\n            op = (v, t) => {\n                return typeof v === 'function' ? v(t) : v;\n            };\n            op = op.bind(null, evaluate(operand, step));\n        }\n        if (!op && !operand) {\n            error(105, expression);\n        }\n        return op;\n    }\n    /**\n     * Given a string like '$name==bobby' evaluate it to true or false\n     * @param operand - A left or right boolean operand \u2014 usually conditions\n     * @param step - The current order of operation\n     * @param fnToken - The token (string) representation of a function being called\n     * @returns\n     */\n    function evaluate(operand, step, fnToken, tail //eslint-disable-line\n    ) {\n        if (fnToken) {\n            const fn = evaluate(fnToken, operatorRegistry.length);\n            let userFuncReturn;\n            // \"Tail calls\" are dot accessors after a function $foo().value. We need\n            // to compile tail calls, and then provide the function result to the\n            // exposed tokens.\n            let tailCall = tail\n                ? compile(`$${tail}`)\n                : false;\n            if (typeof fn === 'function') {\n                const args = parseArgs(String(operand)).map((arg) => evaluate(arg, -1));\n                return (tokens) => {\n                    const userFunc = fn(tokens);\n                    if (typeof userFunc !== 'function') {\n                        warn(150, fnToken);\n                        return userFunc;\n                    }\n                    userFuncReturn = userFunc(...args.map((arg) => typeof arg === 'function' ? arg(tokens) : arg));\n                    if (tailCall) {\n                        tailCall = tailCall.provide((subTokens) => {\n                            const rootTokens = provideTokens(subTokens);\n                            const t = subTokens.reduce((tokenSet, token) => {\n                                const isTail = token === tail || (tail === null || tail === void 0 ? void 0 : tail.startsWith(`${token}(`));\n                                if (isTail) {\n                                    const value = getAt(userFuncReturn, token);\n                                    tokenSet[token] = () => value;\n                                }\n                                else {\n                                    tokenSet[token] = rootTokens[token];\n                                }\n                                return tokenSet;\n                            }, {});\n                            return t;\n                        });\n                    }\n                    return tailCall ? tailCall() : userFuncReturn;\n                };\n            }\n        }\n        else if (typeof operand === 'string') {\n            // the word true or false will never contain further operations\n            if (operand === 'true')\n                return true;\n            if (operand === 'false')\n                return false;\n            if (operand === 'undefined')\n                return undefined;\n            // Truly quotes strings cannot contain an operation, return the string\n            if (isQuotedString(operand))\n                return rmEscapes(operand.substr(1, operand.length - 2));\n            // Actual numbers cannot be contain an operation\n            if (!isNaN(+operand))\n                return Number(operand);\n            if (step < operatorRegistry.length - 1) {\n                return parseLogicals(operand, step + 1);\n            }\n            else {\n                if (operand.startsWith('$')) {\n                    const cleaned = operand.substr(1);\n                    requirements.add(cleaned);\n                    return function getToken(tokens) {\n                        return cleaned in tokens ? tokens[cleaned]() : undefined;\n                    };\n                }\n                // In this case we are dealing with an unquoted string, just treat it\n                // as a plain string.\n                return operand;\n            }\n        }\n        return operand;\n    }\n    /**\n     * Compile the string.\n     */\n    const compiled = parseLogicals(expr.startsWith('$:') ? expr.substr(2) : expr);\n    /**\n     * Convert compiled requirements to an array.\n     */\n    const reqs = Array.from(requirements);\n    /**\n     * Provides token values via callback to compiled output.\n     * @param callback - A callback that needs to provide all token requirements\n     * @returns\n     */\n    function provide(callback) {\n        provideTokens = callback;\n        return Object.assign(compiled.bind(null, callback(reqs)), {\n            provide,\n        });\n    }\n    return Object.assign(compiled, {\n        provide,\n    });\n}\n\n/**\n * Function that produces a standardized object representation of CSS classes\n * @param propertyKey - section key\n * @param node - FormKit node\n * @param sectionClassList - Things to turn into classes\n * @returns\n * @public\n */\nfunction createClasses(propertyKey, node, sectionClassList) {\n    if (!sectionClassList)\n        return {};\n    if (typeof sectionClassList === 'string') {\n        const classKeys = sectionClassList.split(' ');\n        return classKeys.reduce((obj, key) => Object.assign(obj, { [key]: true }), {});\n    }\n    else if (typeof sectionClassList === 'function') {\n        return createClasses(propertyKey, node, sectionClassList(node, propertyKey));\n    }\n    return sectionClassList;\n}\n/**\n * Combines multiple class lists into a single list\n * @param node - the FormKit node being operated on\n * @param property - The property key to which the class list will be applied\n * @param args - CSS class list(s)\n * @returns\n * @public\n */\nfunction generateClassList(node, property, ...args) {\n    const combinedClassList = args.reduce((finalClassList, currentClassList) => {\n        if (!currentClassList)\n            return finalClassList;\n        const { $reset, ...classList } = currentClassList;\n        if ($reset) {\n            return classList;\n        }\n        return Object.assign(finalClassList, classList);\n    }, {});\n    return (Object.keys(node.hook.classes.dispatch({ property, classes: combinedClassList })\n        .classes)\n        .filter((key) => combinedClassList[key])\n        .join(' ') || null);\n}\n\n/**\n * Sets errors on a form, group, or input.\n * @param formId - The id of a form\n * @param localErrors - The errors to set on the form or the form\u2019s inputs\n * @param childErrors - (optional) The errors to set on the form or the form\u2019s inputs\n * @public\n */\nfunction setErrors(id, localErrors, childErrors) {\n    const node = getNode$1(id);\n    if (node) {\n        node.setErrors(localErrors, childErrors);\n    }\n    else {\n        warn(651, id);\n    }\n}\n\nexport { bfs, compile, createClasses, createConfig$1 as createConfig, createMessage, createNode, createValue, deregister, error, errorHandler, generateClassList, getNode$1 as getNode, isComponent, isConditional, isDOM, isList, isNode, isSugar, names, register, reset, resetCount, resetRegistry, setErrors, submitForm, sugar, use, useIndex, valueMoved, valueRemoved, warn, warningHandler, watchRegistry };\n", "import { extend, clone, kebab, has, undefine, camel } from '@formkit/utils';\nimport { warn, createMessage } from '@formkit/core';\n\nconst outer = composable('outer', () => ({\n    $el: 'div',\n    attrs: {\n        class: '$classes.outer',\n        'data-type': '$type',\n        'data-multiple': '$attrs.multiple',\n        'data-disabled': '$disabled || undefined',\n        'data-complete': '$state.complete || undefined',\n        'data-invalid': '$state.valid === false && $state.validationVisible || undefined',\n        'data-errors': '$state.errors || undefined',\n        'data-submitted': '$state.submitted || undefined',\n    },\n}));\n\nconst wrapper$2 = composable('wrapper', () => ({\n    $el: 'div',\n    attrs: {\n        class: '$classes.wrapper',\n    },\n}));\n\nconst inner = composable('inner', () => ({\n    $el: 'div',\n    attrs: {\n        class: '$classes.inner',\n    },\n}));\n\nconst help = (schema = {}, children = [], target = 'help', cond = '$help') => ({\n    if: `$slots.${target}`,\n    then: `$slots.${target}`,\n    else: extend({\n        $el: 'div',\n        attrs: {\n            id: `$: \"help-\" + ${target == 'optionHelp' ? '$option.attrs.id' : '$id'}`,\n            class: `$classes.${target}`,\n        },\n        if: cond,\n        children,\n    }, schema),\n});\n\nconst messages = composable('messages', () => ({\n    $el: 'ul',\n    if: '$fns.length($messages)',\n    attrs: {\n        class: '$classes.messages',\n        'aria-live': '$type === \"form\" && \"assertive\" || \"polite\"',\n    },\n}));\n\nconst message = composable('message', () => ({\n    $el: 'li',\n    for: ['message', '$messages'],\n    attrs: {\n        key: '$message.key',\n        class: '$classes.message',\n        id: `$id + '-' + $message.key`,\n        'data-message-type': '$message.type',\n    },\n}));\n\nconst prefix = composable('prefix', () => ({ $el: null }));\n\nconst suffix = composable('suffix', () => ({ $el: null }));\n\n/**\n * Type guard for schema objects.\n * @param schema - returns true if the node is a schema node but not a string or conditional.\n */\nfunction isSchemaObject(schema) {\n    return (typeof schema === 'object' &&\n        ('$el' in schema || '$cmp' in schema || '$formkit' in schema));\n}\n/**\n * Extends a single schema node with an extension. The extension can be any partial node including strings.\n * @param schema - Extend a base schema node.\n * @param extension - The values to extend on the base schema node.\n * @returns\n * @public\n */\nfunction extendSchema(schema, extension = {}) {\n    if (typeof schema === 'string') {\n        return isSchemaObject(extension) || typeof extension === 'string'\n            ? extension\n            : schema;\n    }\n    else if (Array.isArray(schema)) {\n        return isSchemaObject(extension) ? extension : schema;\n    }\n    return extend(schema, extension);\n}\n/**\n * Creates a new section key.\n *\n * @param key - A new section key name.\n * @param schema - The default schema in this composable slot.\n * @returns\n * @public\n */\nfunction composable(key, schema) {\n    return (extendWith = {}, children = undefined) => {\n        const root = typeof schema === 'function'\n            ? schema(children)\n            : typeof schema === 'object'\n                ? clone(schema)\n                : schema;\n        const isObj = isSchemaObject(root);\n        if (isObj && !('children' in root) && children) {\n            if (Array.isArray(children)) {\n                if (children.length) {\n                    root.children = children;\n                }\n            }\n            else {\n                root.children = [children];\n            }\n        }\n        const extended = extendSchema(root, extendWith);\n        return {\n            if: `$slots.${key}`,\n            then: `$slots.${key}`,\n            else: Array.isArray(extended) ? extended : [extended],\n        };\n    };\n}\n/**\n * Creates an input schema with all of the wrapping base schema.\n * @param inputSchema - Content to store in the input section key location.\n * @public\n */\nfunction useSchema(inputSchema) {\n    return (extensions = {}) => {\n        const input = composable('input', inputSchema)(extensions.input);\n        return [\n            outer(extensions.outer, [\n                wrapper$2(extensions.wrapper, [\n                    label(extensions.label, '$label'),\n                    inner(extensions.inner, [\n                        prefix(extensions.prefix),\n                        ...(Array.isArray(input) ? input : [input]),\n                        suffix(extensions.prefix),\n                    ]),\n                ]),\n                help(extensions.help, '$help'),\n                messages(extensions.messages, [\n                    message(extensions.message, '$message.value'),\n                ]),\n            ]),\n        ];\n    };\n}\n\nconst label = composable('label', () => ({\n    $el: 'label',\n    if: '$label',\n    attrs: {\n        for: '$id',\n        class: '$classes.label',\n    },\n}));\n\nconst text$1 = composable('input', () => ({\n    $el: 'input',\n    bind: '$attrs',\n    attrs: {\n        type: '$type',\n        disabled: '$disabled',\n        class: '$classes.input',\n        name: '$node.name',\n        onInput: '$handlers.DOMInput',\n        onBlur: '$handlers.blur',\n        value: '$_value',\n        id: '$id',\n        'aria-describedby': '$describedBy',\n    },\n}));\n\n/**\n * The schema for text classifications.\n * @public\n */\nconst textSchema$1 = (extensions = {}) => [\n    outer(extensions.outer, [\n        wrapper$2(extensions.wrapper, [\n            label(extensions.label, '$label'),\n            inner(extensions.inner, [\n                prefix(extensions.prefix),\n                text$1(extensions.input),\n                suffix(extensions.suffix),\n            ]),\n        ]),\n        help(extensions.help, '$help'),\n        messages(extensions.messages, [\n            message(extensions.message, '$message.value'),\n        ]),\n    ]),\n];\n\nconst file$1 = composable('input', () => ({\n    $el: 'input',\n    bind: '$attrs',\n    attrs: {\n        type: 'file',\n        foo: 'bar',\n        disabled: '$disabled',\n        class: '$classes.input',\n        name: '$node.name',\n        onChange: '$handlers.files',\n        onBlur: '$handlers.blur',\n        id: '$id',\n        'aria-describedby': '$describedBy',\n    },\n}));\n\nconst fileList = composable('fileList', () => ({\n    $el: 'ul',\n    if: '$value.length',\n    attrs: {\n        class: '$classes.fileList',\n        'data-has-multiple': {\n            if: '$value.length > 1',\n            then: 'true',\n        },\n    },\n}));\n\nconst fileItem = composable('fileItem', () => ({\n    $el: 'li',\n    for: ['file', '$value'],\n    attrs: {\n        class: '$classes.fileItem',\n    },\n}));\n\nconst fileName = composable('fileName', () => ({\n    $el: 'span',\n    attrs: {\n        class: '$classes.fileName',\n    },\n}));\n\nconst noFiles = composable('noFiles', () => ({\n    $el: 'span',\n    if: '$value.length == 0',\n    attrs: {\n        class: '$classes.noFiles',\n    },\n}));\n\nconst removeFiles = composable('removeFiles', () => ({\n    $el: 'a',\n    attrs: {\n        href: '#',\n        class: '$classes.removeFiles',\n        onClick: '$handlers.resetFiles',\n    },\n}));\n\n/**\n * The schema for text classifications.\n * @public\n */\nconst fileSchema = (extensions = {}) => [\n    outer(extensions.outer, [\n        wrapper$2(extensions.wrapper, [\n            label(extensions.label, '$label'),\n            inner(extensions.inner, [\n                prefix(extensions.prefix),\n                file$1(extensions.input),\n                fileList(extensions.fileList, [\n                    fileItem(extensions.file, [\n                        fileName(extensions.fileName, '$file.name'),\n                        {\n                            if: '$value.length == 1',\n                            then: removeFiles(extensions.removeFiles, '$ui.remove.value'),\n                        },\n                    ]),\n                ]),\n                {\n                    if: '$value.length > 1',\n                    then: removeFiles(extensions.removeFiles, '$ui.removeAll.value'),\n                },\n                noFiles(extensions.noFiles, '$ui.noFiles.value'),\n                suffix(extensions.suffix),\n            ]),\n        ]),\n        help(extensions.help, '$help'),\n        messages(extensions.messages, [\n            message(extensions.message, '$message.value'),\n        ]),\n    ]),\n];\n\nconst textarea$1 = composable('input', () => ({\n    $el: 'textarea',\n    bind: '$attrs',\n    attrs: {\n        class: '$classes.input',\n        disabled: '$disabled',\n        name: '$node.name',\n        onInput: '$handlers.DOMInput',\n        onBlur: '$handlers.blur',\n        value: '$_value',\n        id: '$id',\n        'aria-describedby': '$describedBy',\n    },\n    children: '$initialValue',\n}));\n\n/**\n * The schema for textarea classifications.\n * @public\n */\nconst textareaSchema = (extensions = {}) => [\n    outer(extensions.outer, [\n        wrapper$2(extensions.wrapper, [\n            label(extensions.label, '$label'),\n            inner(extensions.inner, [\n                prefix(extensions.prefix),\n                textarea$1(extensions.input),\n                suffix(extensions.suffix),\n            ]),\n        ]),\n        help(extensions.help, '$help'),\n        messages(extensions.messages, [\n            message(extensions.message, '$message.value'),\n        ]),\n    ]),\n];\n\n/**\n * The schema for text classifications.\n * @public\n */\nconst hiddenSchema = (extensions = {}) => [\n    text$1(extensions.input),\n];\n\nconst fragment = (schema = {}, children = []) => (Object.keys(schema).length || typeof children !== 'string'\n    ? extend({ $el: 'div', children }, schema)\n    : children);\n\nconst groupSchema = (extensions = {}) => {\n    return [fragment(extensions.wrapper, '$slots.default')];\n};\n\nconst listSchema = (extensions = {}) => {\n    return [fragment(extensions.wrapper, '$slots.default')];\n};\n\nconst select$1 = composable('input', (children) => ({\n    $el: 'select',\n    bind: '$attrs',\n    attrs: {\n        id: '$id',\n        'data-placeholder': {\n            if: '$placeholder',\n            then: {\n                if: '$value',\n                then: undefined,\n                else: 'true',\n            },\n        },\n        disabled: '$disabled',\n        class: '$classes.input',\n        name: '$node.name',\n        onInput: '$handlers.selectInput',\n        onBlur: '$handlers.blur',\n        'aria-describedby': '$describedBy',\n    },\n    children: {\n        if: '$slots.default',\n        then: '$slots.default',\n        else: children,\n    },\n}));\n\nconst option = (schema = {}, children = []) => ({\n    if: '$slots.option',\n    then: [\n        {\n            $el: 'text',\n            if: '$options.length',\n            for: ['option', '$options'],\n            children: '$slots.option',\n        },\n    ],\n    else: extend({\n        $el: 'option',\n        if: '$options.length',\n        for: ['option', '$options'],\n        bind: '$option.attrs',\n        attrs: {\n            class: '$classes.option',\n            value: '$option.value',\n            selected: '$fns.isSelected($option.value)',\n        },\n        children,\n    }, schema),\n});\n\n/**\n * The schema for text classifications.\n * @public\n */\nconst textSchema = (extensions = {}) => [\n    outer(extensions.outer, [\n        wrapper$2(extensions.wrapper, [\n            label(extensions.label, '$label'),\n            inner(extensions.inner, [\n                prefix(extensions.prefix),\n                select$1(extensions.input, [option(extensions.option, '$option.label')]),\n                suffix(extensions.suffix),\n            ]),\n        ]),\n        help(extensions.help, '$help'),\n        messages(extensions.messages, [\n            message(extensions.message, '$message.value'),\n        ]),\n    ]),\n];\n\nconst boxLabel = composable('label', (children) => ({\n    $el: 'span',\n    if: typeof children === 'string' ? children : '$: true',\n    attrs: {\n        class: '$classes.label',\n    },\n}));\n\nconst wrapper$1 = composable('wrapper', () => ({\n    $el: 'label',\n    attrs: {\n        class: '$classes.wrapper',\n        'data-disabled': {\n            if: '$options.length',\n            then: undefined,\n            else: '$disabled',\n        },\n    },\n}));\n\nconst box = composable('input', () => ({\n    $el: 'input',\n    bind: '$attrs',\n    attrs: {\n        type: '$type',\n        class: '$classes.input',\n        name: '$node.props.altName || $node.name',\n        disabled: '$option.attrs.disabled || $disabled',\n        onInput: '$handlers.toggleChecked',\n        checked: '$_value === $onValue',\n        onBlur: '$handlers.blur',\n        value: '$: true',\n        id: '$id',\n        'aria-describedby': {\n            if: '$options.length',\n            then: {\n                if: '$option.help',\n                then: '$: \"help-\" + $option.attrs.id',\n                else: undefined,\n            },\n            else: {\n                if: '$help',\n                then: '$: \"help-\" + $id',\n                else: undefined,\n            },\n        },\n    },\n}));\n\nconst fieldset = composable('fieldset', () => ({\n    $el: 'fieldset',\n    attrs: {\n        id: '$id',\n        class: '$classes.fieldset',\n        'aria-describedby': {\n            if: '$help',\n            then: '$: \"help-\" + $id',\n            else: undefined,\n        },\n    },\n}));\n\nconst legend = composable('legend', () => ({\n    $el: 'legend',\n    if: '$label',\n    attrs: {\n        class: '$classes.legend',\n    },\n}));\n\nconst boxes = composable('option', () => ({\n    $el: 'li',\n    for: ['option', '$options'],\n    attrs: {\n        class: '$classes.option',\n        'data-disabled': '$option.attrs.disabled || $disabled',\n    },\n}));\n\nconst wrapper = composable('options', () => ({\n    $el: 'ul',\n    attrs: {\n        class: '$classes.options',\n    },\n}));\n\nconst decorator = composable('decorator', () => ({\n    $el: 'span',\n    attrs: {\n        class: '$classes.decorator',\n        'aria-hidden': 'true',\n    },\n}));\n\n/**\n * The schema for text classifications.\n * @public\n */\nconst boxSchema = (extensions = {}) => {\n    const singleCheckbox = [\n        wrapper$1(extensions.wrapper, [\n            inner(extensions.inner, [\n                prefix(extensions.prefix),\n                box(extensions.input),\n                decorator(extensions.decorator),\n                suffix(extensions.suffix),\n            ]),\n            boxLabel(extensions.label, '$label'),\n        ]),\n        help(extensions.help, '$help'),\n    ];\n    const multiCheckbox = fieldset(extensions.fieldset, [\n        legend(extensions.legend, '$label'),\n        help(extensions.help, '$help'),\n        wrapper(extensions.options, [\n            boxes(extensions.option, [\n                wrapper$1(extensions.wrapper, [\n                    inner(extensions.inner, [\n                        prefix(extensions.prefix),\n                        box(extend({\n                            bind: '$option.attrs',\n                            attrs: {\n                                id: '$option.attrs.id',\n                                value: '$option.value',\n                                checked: '$fns.isChecked($option.value)',\n                            },\n                        }, extensions.input || {})),\n                        decorator(extensions.decorator),\n                        suffix(extensions.suffix),\n                    ]),\n                    boxLabel(extensions.label, '$option.label'),\n                ]),\n                help(extensions.optionHelp, '$option.help', 'optionHelp', '$option.help'),\n            ]),\n        ]),\n    ]);\n    return [\n        outer(extensions.outer, [\n            {\n                if: '$options.length',\n                then: multiCheckbox,\n                else: singleCheckbox,\n            },\n            messages(extensions.messages, [\n                message(extensions.message, '$message.value'),\n            ]),\n        ]),\n    ];\n};\n\nconst actions = composable('actions', () => ({\n    $el: 'div',\n    if: '$actions',\n    attrs: {\n        class: '$classes.actions',\n    },\n}));\n\nconst form$1 = composable('form', () => ({\n    $el: 'form',\n    bind: '$attrs',\n    attrs: {\n        id: '$id',\n        class: '$classes.form',\n        name: '$node.name',\n        onSubmit: '$handlers.submit',\n        'data-loading': '$state.loading || undefined',\n    },\n}));\n\nconst submit$1 = composable('submit', () => ({\n    $cmp: 'FormKit',\n    bind: '$submitAttrs',\n    props: {\n        ignore: true,\n        type: 'submit',\n        disabled: '$disabled',\n        label: '$submitLabel',\n    },\n}));\n\nconst formSchema = (extensions = {}) => {\n    return [\n        form$1(extensions.form, [\n            '$slots.default',\n            messages(extensions.messages, [\n                message(extensions.message, '$message.value'),\n            ]),\n            actions(extensions.actions, [submit$1(extensions.submit)]),\n        ]),\n    ];\n};\n\nconst button$1 = composable('input', () => ({\n    $el: 'button',\n    bind: '$attrs',\n    attrs: {\n        type: '$type',\n        disabled: '$disabled',\n        class: '$classes.input',\n        name: '$node.name',\n        id: '$id',\n    },\n}));\n\n/**\n * The schema for text classifications.\n * @public\n */\nconst buttonSchema = (extensions = {}) => [\n    outer(extensions.outer, [\n        messages(extensions.messages, [\n            message(extensions.message, '$message.value'),\n        ]),\n        wrapper$2(extensions.wrapper, [\n            button$1(extensions.input, [\n                prefix(extensions.prefix),\n                {\n                    if: '$slots.default',\n                    then: '$slots.default',\n                    else: {\n                        if: '$label',\n                        then: '$label',\n                        else: '$ui.submit.value',\n                    },\n                },\n                suffix(extensions.suffix),\n            ]),\n        ]),\n        help(extensions.help, '$help'),\n    ]),\n];\n\n/**\n * Accepts an array of objects, array of strings, or object of key-value pairs.\n * and returns an array of objects with value and label properties.\n * @param options -\n */\nfunction normalizeOptions(options) {\n    if (Array.isArray(options)) {\n        return options.map((option) => {\n            if (typeof option === 'string' || typeof option === 'number') {\n                return {\n                    label: option,\n                    value: option,\n                };\n            }\n            return option;\n        });\n    }\n    return Object.keys(options).map((value) => {\n        return {\n            label: options[value],\n            value,\n        };\n    });\n}\n/**\n * Converts the options prop to usable values.\n * @param node - A formkit node.\n */\nfunction formatsOptions (node) {\n    node.hook.prop((prop, next) => {\n        if (prop.prop === 'options') {\n            const options = normalizeOptions(prop.value);\n            prop.value = options;\n        }\n        return next(prop);\n    });\n}\n\n/**\n * Checks if a the given option should have the selected attribute.\n * @param node - The node being evaluated.\n * @param option - The option value to check\n * @returns\n */\nfunction isSelected(node, option) {\n    // Here we trick reactivity (if at play) to watch this function.\n    node.context && node.context.value;\n    return Array.isArray(node._value)\n        ? node._value.includes(option)\n        : (node.value === undefined && !option) || node._value == option;\n}\n/**\n * Select the correct values.\n * @param e - The input event emitted by the select.\n */\nfunction selectInput(node, e) {\n    const target = e.target;\n    const value = target.hasAttribute('multiple')\n        ? Array.from(target.selectedOptions).map((o) => o.value)\n        : target.value;\n    node.input(value);\n}\n/**\n * Appends a placeholder to the options list.\n * @param options - An options list\n * @param placeholder - A placeholder string to append\n * @returns\n */\nfunction applyPlaceholder(options, placeholder) {\n    if (!options.some((option) => option.attrs && option.attrs['data-is-placeholder'])) {\n        return [\n            {\n                label: placeholder,\n                value: '',\n                attrs: {\n                    hidden: true,\n                    disabled: true,\n                    'data-is-placeholder': 'true',\n                },\n            },\n            ...options,\n        ];\n    }\n    return options;\n}\n/**\n * Converts the options prop to usable values.\n * @param node - A formkit node.\n */\nfunction selectFeatures (node) {\n    // Set the initial value of a multi-input\n    node.on('created', () => {\n        var _a, _b, _c;\n        const isMultiple = ((_a = node.props.attrs) === null || _a === void 0 ? void 0 : _a.multiple) !== undefined;\n        if (!isMultiple &&\n            node.props.placeholder &&\n            Array.isArray(node.props.options)) {\n            node.hook.prop(({ prop, value }, next) => {\n                if (prop === 'options') {\n                    value = applyPlaceholder(value, node.props.placeholder);\n                }\n                return next({ prop, value });\n            });\n            node.props.options = applyPlaceholder(node.props.options, node.props.placeholder);\n        }\n        if (isMultiple) {\n            if (node.value === undefined) {\n                node.input([], false);\n            }\n        }\n        else if (node.context && !node.context.options) {\n            // If this input us (probably) using the default slot, we need to add a\n            // \"value\" attribute to get bound\n            node.props.attrs = Object.assign({}, node.props.attrs, {\n                value: node._value,\n            });\n            node.on('input', ({ payload }) => {\n                node.props.attrs = Object.assign({}, node.props.attrs, {\n                    value: payload,\n                });\n            });\n        }\n        if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.handlers) {\n            node.context.handlers.selectInput = selectInput.bind(null, node);\n        }\n        if ((_c = node.context) === null || _c === void 0 ? void 0 : _c.fns) {\n            node.context.fns.isSelected = isSelected.bind(null, node);\n        }\n    });\n    node.hook.input((value, next) => {\n        var _a, _b;\n        if (!node.props.placeholder &&\n            value === undefined &&\n            Array.isArray((_a = node.props) === null || _a === void 0 ? void 0 : _a.options) &&\n            node.props.options.length &&\n            !('multiple' in ((_b = node.props) === null || _b === void 0 ? void 0 : _b.attrs))) {\n            value = node.props.options[0].value;\n        }\n        return next(value);\n    });\n}\n\nfunction normalizeBoxes (node) {\n    return function (prop, next) {\n        if (prop.prop === 'options' && Array.isArray(prop.value)) {\n            prop.value = prop.value.map((option) => {\n                var _a;\n                if (!((_a = option.attrs) === null || _a === void 0 ? void 0 : _a.id)) {\n                    return extend(option, {\n                        attrs: { id: `${node.name}-option-${kebab(String(option.value))}` },\n                    });\n                }\n                return option;\n            });\n            if (node.props.type === 'checkbox' && !Array.isArray(node.value)) {\n                if (node.isCreated) {\n                    node.input([], false);\n                }\n                else {\n                    node.on('created', () => {\n                        if (!Array.isArray(node.value)) {\n                            node.input([], false);\n                        }\n                    });\n                }\n            }\n        }\n        return next(prop);\n    };\n}\n\n/**\n * Event handler when an input is toggled.\n * @param node - The node being toggled\n * @param e - The input even related to the toggling\n */\nfunction toggleChecked$1(node, e) {\n    const el = e.target;\n    if (el instanceof HTMLInputElement) {\n        if (Array.isArray(node.props.options) && node.props.options.length) {\n            if (!Array.isArray(node._value)) {\n                node.input([el.value]);\n            }\n            else if (!node._value.includes(el.value)) {\n                node.input([...node._value, el.value]);\n            }\n            else {\n                node.input(node._value.filter((val) => val !== el.value));\n            }\n        }\n        else {\n            if (el.checked) {\n                node.input(node.props.onValue);\n            }\n            else {\n                node.input(node.props.offValue);\n            }\n        }\n    }\n}\n/**\n * Checks if a given option is present in the node value.\n * @param node - The node being checked\n * @param value - The value of any option\n * @returns\n */\nfunction isChecked$1(node, value) {\n    var _a, _b;\n    // We need to force vue\u2019s reactivity to respond when the value is run:\n    (_a = node.context) === null || _a === void 0 ? void 0 : _a.value;\n    (_b = node.context) === null || _b === void 0 ? void 0 : _b._value;\n    return Array.isArray(node._value) ? node._value.includes(value) : false;\n}\n/**\n * Adds checkbox selection support\n * @param node - Node the feature is added to\n */\nfunction checkboxes (node) {\n    node.on('created', () => {\n        var _a, _b;\n        if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {\n            node.context.handlers.toggleChecked = toggleChecked$1.bind(null, node);\n        }\n        if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.fns) {\n            node.context.fns.isChecked = isChecked$1.bind(null, node);\n        }\n        // Configure our default onValue and offValue\n        if (!has(node.props, 'onValue'))\n            node.props.onValue = true;\n        if (!has(node.props, 'offValue'))\n            node.props.offValue = false;\n    });\n    node.hook.prop(normalizeBoxes(node));\n}\n\n/**\n * Sets the value of a radio button when checked.\n * @param node - FormKitNode\n * @param value - Value\n */\nfunction toggleChecked(node, event) {\n    if (event.target instanceof HTMLInputElement) {\n        node.input(event.target.value);\n    }\n}\n/**\n * Checks if the value being checked is the current value.\n * @param node - The node to check against.\n * @param value - The value to check\n * @returns\n */\nfunction isChecked(node, value) {\n    var _a, _b;\n    // We need to force vue\u2019s reactivity to respond when the value is run:\n    (_a = node.context) === null || _a === void 0 ? void 0 : _a.value;\n    (_b = node.context) === null || _b === void 0 ? void 0 : _b._value;\n    return node._value == value;\n}\n/**\n * Determines if a given radio input is being evaluated.\n * @param node - The radio input group.\n */\nfunction radios(node) {\n    node.on('created', () => {\n        var _a, _b;\n        if (!Array.isArray(node.props.options)) {\n            warn(350, node);\n        }\n        if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {\n            node.context.handlers.toggleChecked = toggleChecked.bind(null, node);\n        }\n        if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.fns) {\n            node.context.fns.isChecked = isChecked.bind(null, node);\n        }\n    });\n    node.hook.prop(normalizeBoxes(node));\n}\n\n/**\n * Allows disabling children of this.\n * @param node - The FormKitNode of the form/group/list\n */\nfunction disablesChildren (node) {\n    node.hook.prop(({ prop, value }, next) => {\n        value = prop === 'disabled' ? undefine(value) : value;\n        return next({ prop, value });\n    });\n    node.on('prop:disabled', ({ payload: value }) => {\n        node.config.disabled = value;\n    });\n    node.on('created', () => {\n        node.config.disabled = undefine(node.props.disabled);\n    });\n}\n\n/**\n * Handle the submit event.\n * @param e - The event\n */\nasync function handleSubmit(node, submitEvent) {\n    submitEvent.preventDefault();\n    await node.settled;\n    // Set the submitted state on all children\n    node.walk((n) => {\n        n.store.set(createMessage({\n            key: 'submitted',\n            value: true,\n            visible: false,\n        }));\n    });\n    if (typeof node.props.onSubmitRaw === 'function') {\n        node.props.onSubmitRaw(submitEvent);\n    }\n    if (node.ledger.value('blocking')) {\n        // There is still a blocking message in the store.\n        if (node.props.incompleteMessage !== false) {\n            node.store.set(createMessage({\n                blocking: false,\n                key: `incomplete`,\n                meta: {\n                    localize: node.props.incompleteMessage === undefined,\n                    i18nArgs: [{ node }],\n                    showAsMessage: true,\n                },\n                type: 'ui',\n                value: node.props.incompleteMessage || 'Form incomplete.',\n            }));\n        }\n    }\n    else {\n        // No blocking messages\n        if (typeof node.props.onSubmit === 'function') {\n            // call onSubmit\n            const retVal = node.props.onSubmit(clone(node.value), node);\n            if (retVal instanceof Promise) {\n                const autoDisable = node.props.disabled === undefined &&\n                    node.props.submitBehavior !== 'live';\n                if (autoDisable)\n                    node.props.disabled = true;\n                node.store.set(createMessage({\n                    key: 'loading',\n                    value: true,\n                    visible: false,\n                }));\n                await retVal;\n                if (autoDisable)\n                    node.props.disabled = false;\n                node.store.remove('loading');\n            }\n        }\n        else {\n            if (submitEvent.target instanceof HTMLFormElement) {\n                submitEvent.target.submit();\n            }\n        }\n    }\n}\n/**\n * Converts the options prop to usable values.\n * @param node - A formkit node.\n */\nfunction formHandler (node) {\n    node.props.isForm = true;\n    node.on('created', () => {\n        var _a;\n        if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {\n            node.context.handlers.submit = handleSubmit.bind(null, node);\n        }\n        if (!has(node.props, 'actions')) {\n            node.props.actions = true;\n        }\n    });\n    node.on('settled:blocking', () => node.store.remove('incomplete'));\n}\n\n/**\n * Creates a new feature that generates a localization message of type ui\n * for use on a given component.\n *\n * @param key - The key of the message\n * @param value - The value of the message\n * @returns\n * @public\n */\nfunction localize(key, value) {\n    return (node) => {\n        node.store.set(createMessage({\n            key,\n            type: 'ui',\n            value: value || key,\n            meta: {\n                localize: true,\n                i18nArgs: [node],\n            },\n        }));\n    };\n}\n\nconst isBrowser = typeof window !== 'undefined';\n/**\n * Remove the data-file-hover attribute from the target.\n * @param e - Event\n */\nfunction removeHover(e) {\n    if (e.target instanceof HTMLElement &&\n        e.target.hasAttribute('data-file-hover')) {\n        e.target.removeAttribute('data-file-hover');\n    }\n}\n/**\n * Prevent stray drag/drop events from navigating the window.\n * @param e - Event\n */\nfunction preventStrayDrop(type, e) {\n    if (!(e.target instanceof HTMLInputElement)) {\n        e.preventDefault();\n    }\n    else if (type === 'dragover') {\n        e.target.setAttribute('data-file-hover', 'true');\n    }\n    if (type === 'drop') {\n        removeHover(e);\n    }\n}\nfunction files (node) {\n    // Localize our content:\n    localize('noFiles', 'Select file')(node);\n    localize('removeAll', 'Remove all')(node);\n    localize('remove')(node);\n    if (isBrowser) {\n        if (!window._FormKit_File_Drop) {\n            window.addEventListener('dragover', preventStrayDrop.bind(null, 'dragover'));\n            window.addEventListener('drop', preventStrayDrop.bind(null, 'drop'));\n            window.addEventListener('dragleave', removeHover);\n            window._FormKit_File_Drop = true;\n        }\n    }\n    node.on('created', () => {\n        if (!Array.isArray(node.value)) {\n            node.input([], false);\n        }\n        if (!node.context)\n            return;\n        node.context.handlers.resetFiles = (e) => {\n            e.preventDefault();\n            node.input([]);\n            if (node.props.id && isBrowser) {\n                const el = document.getElementById(node.props.id);\n                if (el)\n                    el.value = '';\n            }\n        };\n        node.context.handlers.files = (e) => {\n            var _a, _b;\n            const files = [];\n            if (e.target instanceof HTMLInputElement && e.target.files) {\n                for (let i = 0; i < e.target.files.length; i++) {\n                    let file;\n                    if ((file = e.target.files.item(i))) {\n                        files.push({ name: file.name, file });\n                    }\n                }\n                node.input(files);\n            }\n            if (node.context)\n                node.context.files = files;\n            // Call the original listener if there is one.\n            if (typeof ((_a = node.props.attrs) === null || _a === void 0 ? void 0 : _a.onChange) === 'function') {\n                (_b = node.props.attrs) === null || _b === void 0 ? void 0 : _b.onChange(e);\n            }\n        };\n    });\n}\n\n/**\n * Applies ignore=\"true\" by default.\n * @param node - The node\n */\nfunction ignore (node) {\n    if (node.props.ignore === undefined) {\n        node.props.ignore = true;\n        node.parent = null;\n    }\n}\n\nfunction initialValue(node) {\n    node.on('created', () => {\n        if (node.context) {\n            node.context.initialValue = node.value || '';\n        }\n    });\n}\n\n/**\n * Default classifications that are available.\n */\nconst textClassification = {\n    type: 'input',\n    schema: textSchema$1,\n};\n/**\n * The color input.\n * @public\n */\nconst color = textClassification;\n/**\n * The date input.\n * @public\n */\nconst date = textClassification;\n/**\n * The datetime-local input.\n * @public\n */\nconst datetimeLocal = textClassification;\n/**\n * The email input.\n * @public\n */\nconst email = textClassification;\n/**\n * The month input.\n * @public\n */\nconst month = textClassification;\n/**\n * The number input.\n * @public\n */\nconst number = textClassification;\n/**\n * The password input.\n * @public\n */\nconst password = textClassification;\n/**\n * The search input.\n * @public\n */\nconst search = textClassification;\n/**\n * The tel input.\n * @public\n */\nconst tel = textClassification;\n/**\n * The time input.\n * @public\n */\nconst time = textClassification;\n/**\n * The text input.\n * @public\n */\nconst text = textClassification;\n/**\n * The url input.\n * @public\n */\nconst url = textClassification;\n/**\n * The week input.\n * @public\n */\nconst week = textClassification;\n/**\n * The range input.\n * @public\n */\nconst range = textClassification;\n/**\n * The textarea input.\n * @public\n */\nconst textarea = {\n    type: 'input',\n    schema: textareaSchema,\n    features: [initialValue],\n};\n/**\n * Buttons are all this classification:\n */\nconst buttonClassification = {\n    type: 'input',\n    schema: buttonSchema,\n    features: [localize('submit'), ignore],\n};\n/**\n * The submit input.\n * @public\n */\nconst submit = buttonClassification;\n/**\n * The button classification.\n * @public\n */\nconst button = buttonClassification;\n/**\n * The hidden input.\n * @public\n */\nconst hidden = {\n    type: 'input',\n    schema: hiddenSchema,\n};\n/**\n * The group input type.\n * @public\n */\nconst select = {\n    type: 'input',\n    schema: textSchema,\n    props: ['options', 'placeholder'],\n    features: [formatsOptions, selectFeatures],\n};\n/**\n * The checkbox input type.\n * @public\n */\nconst checkbox = {\n    type: 'input',\n    schema: boxSchema,\n    props: ['options', 'onValue', 'offValue'],\n    features: [formatsOptions, checkboxes],\n};\n/**\n * The radio input type.\n * @public\n */\nconst radio = {\n    type: 'input',\n    schema: boxSchema,\n    props: ['options'],\n    features: [formatsOptions, radios],\n};\n/**\n * The group input type.\n * @public\n */\nconst group = {\n    type: 'group',\n    schema: groupSchema,\n    features: [disablesChildren],\n};\n/**\n * The group input type.\n * @public\n */\nconst form = {\n    type: 'group',\n    schema: formSchema,\n    props: [\n        'actions',\n        'submit',\n        'submitLabel',\n        'submitAttrs',\n        'submitBehavior',\n        'incompleteMessage',\n    ],\n    features: [formHandler, disablesChildren],\n};\n/**\n * The group input type.\n * @public\n */\nconst list = {\n    type: 'list',\n    schema: listSchema,\n    features: [disablesChildren],\n};\n/**\n * The file input.\n * @public\n */\nconst file = {\n    type: 'input',\n    schema: fileSchema,\n    features: [files],\n    props: ['files'],\n};\n\nvar inputs = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    color: color,\n    date: date,\n    datetimeLocal: datetimeLocal,\n    email: email,\n    month: month,\n    number: number,\n    password: password,\n    search: search,\n    tel: tel,\n    time: time,\n    text: text,\n    url: url,\n    week: week,\n    range: range,\n    textarea: textarea,\n    submit: submit,\n    button: button,\n    hidden: hidden,\n    select: select,\n    checkbox: checkbox,\n    radio: radio,\n    group: group,\n    form: form,\n    list: list,\n    file: file\n});\n\n/**\n *\n * @param libraries - One or many formkit urls.\n * @returns\n * @public\n */\nfunction createLibraryPlugin(...libraries) {\n    /**\n     * Merge all provided library items.\n     */\n    const library = libraries.reduce((merged, lib) => extend(merged, lib), {});\n    /* eslint-disable-next-line @typescript-eslint/no-empty-function */\n    const plugin = () => { };\n    /**\n     * Enables the hook that exposes all library inputs.\n     * @param node - The primary plugin\n     */\n    plugin.library = function (node) {\n        const type = camel(node.props.type);\n        if (has(library, type)) {\n            node.define(library[type]);\n        }\n    };\n    return plugin;\n}\n\nexport { button, checkbox, color, composable, createLibraryPlugin, date, datetimeLocal, email, extendSchema, file, form, group, hidden, inputs, list, localize, month, number, password, radio, range, search, select, submit, tel, text, textarea, time, url, useSchema, week };\n", "import { has, regexForFormat, eq, empty } from '@formkit/utils';\n\n/**\n * Determine if the given input's value was should be considered \"accepted\".\n * @param context - The FormKitValidationContext\n * @public\n */\nconst accepted = function accepted({ value }) {\n    return ['yes', 'on', '1', 1, true, 'true'].includes(value);\n};\n\n/**\n * Determine if the given input's value is after a given date.\n * Defaults to current time.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_after = function ({ value }, compare = false) {\n    const timestamp = Date.parse(compare || new Date());\n    const fieldValue = Date.parse(String(value));\n    return isNaN(fieldValue) ? false : fieldValue > timestamp;\n};\n\n/**\n * Determine if the given input's value is only alpha characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst alpha = function ({ value }, set = 'default') {\n    const sets = {\n        default: /^[a-zA-Z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF\u0104\u0105\u0106\u0107\u0118\u0119\u0141\u0142\u0143\u0144\u015A\u015B\u0179\u017A\u017B\u017C]+$/,\n        latin: /^[a-zA-Z]+$/,\n    };\n    const selectedSet = has(sets, set) ? set : 'default';\n    return sets[selectedSet].test(String(value));\n};\n\n/**\n * Determine if the given input's value is only alpha characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst alpha_spaces = function ({ value }, set = 'default') {\n    const sets = {\n        default: /^[a-zA-Z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF\u0104\u0105\u0106\u0107\u0118\u0119\u0141\u0142\u0143\u0144\u015A\u015B\u0179\u017A\u017B\u017C ]+$/,\n        latin: /^[a-zA-Z ]+$/,\n    };\n    const selectedSet = has(sets, set) ? set : 'default';\n    return sets[selectedSet].test(String(value));\n};\n\n/**\n * Determine if the given input's value is only alpha or numeric characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst alphanumeric = function ({ value }, set = 'default') {\n    const sets = {\n        default: /^[a-zA-Z0-9\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF\u0104\u0105\u0106\u0107\u0118\u0119\u0141\u0142\u0143\u0144\u015A\u015B\u0179\u017A\u017B\u017C]+$/,\n        latin: /^[a-zA-Z0-9]+$/,\n    };\n    const selectedSet = has(sets, set) ? set : 'default';\n    return sets[selectedSet].test(String(value));\n};\n\n/**\n * Determine if the given input's value before a given date.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_before = function ({ value }, compare = false) {\n    const timestamp = Date.parse(compare || new Date());\n    const fieldValue = Date.parse(String(value));\n    return isNaN(fieldValue) ? false : fieldValue < timestamp;\n};\n\n/**\n * Determine if the given input's value is between two other values.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst between = function between({ value }, from, to) {\n    if (!isNaN(value) && !isNaN(from) && !isNaN(to)) {\n        const val = 1 * value;\n        from = Number(from);\n        to = Number(to);\n        const [a, b] = from <= to ? [from, to] : [to, from];\n        return val >= 1 * a && val <= 1 * b;\n    }\n    return false;\n};\n\nconst hasConfirm = /(_confirm(?:ed)?)$/;\n/**\n * Determine if the given input's value matches another input's value\n * @param context - The FormKitValidationContext\n * @public\n */\nconst confirm = function confirm(node, address, comparison = 'loose') {\n    var _a;\n    if (!address) {\n        address = hasConfirm.test(node.name)\n            ? node.name.replace(hasConfirm, '')\n            : `${node.name}_confirm`;\n    }\n    const foreignValue = (_a = node.at(address)) === null || _a === void 0 ? void 0 : _a.value;\n    return comparison === 'strict'\n        ? node.value === foreignValue\n        : node.value == foreignValue;\n};\n\n/**\n * Determine if the given input's value is between two other dates\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_between = function date_between({ value }, dateA, dateB) {\n    dateA = dateA instanceof Date ? dateA.getTime() : Date.parse(dateA);\n    dateB = dateB instanceof Date ? dateB.getTime() : Date.parse(dateB);\n    const compareTo = value instanceof Date ? value.getTime() : Date.parse(String(value));\n    if (dateA && !dateB) {\n        dateB = dateA;\n        dateA = Date.now();\n    }\n    else if (!dateA || !compareTo) {\n        return false;\n    }\n    return compareTo >= dateA && compareTo <= dateB;\n};\n\n/**\n * Determine if the given input's value matches a specified date format\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_format = function date({ value }, format) {\n    if (format && typeof format === 'string') {\n        return regexForFormat(format).test(String(value));\n    }\n    return !isNaN(Date.parse(String(value)));\n};\n\n/**\n * Determine if the given input's value is a plausible email address.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst email = function email({ value }) {\n    const isEmail = /^(([^<>()\\[\\]\\.,;:\\s@\\\"]+(\\.[^<>()\\[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^<>()[\\]\\.,;:\\s@\\\"]+\\.)+[^<>()[\\]\\.,;:\\s@\\\"]{2,})$/i;\n    return isEmail.test(String(value));\n};\n\n/**\n * Determine if the given input's value ends with a given string\n * @param context - The FormKitValidationContext\n * @public\n */\nconst ends_with = function ends_with({ value }, ...stack) {\n    if (typeof value === 'string' && stack.length) {\n        return stack.some((item) => {\n            return value.endsWith(item);\n        });\n    }\n    else if (typeof value === 'string' && stack.length === 0) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * Determine if the given input's value is in a set of possible values.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst is = function is({ value }, ...stack) {\n    return stack.some((item) => {\n        if (typeof item === 'object') {\n            return eq(item, value);\n        }\n        return item == value;\n    });\n};\n\n/**\n * Determine if the given input's value length is full width.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst length = function length({ value }, first = 0, second = Infinity) {\n    first = parseInt(first);\n    second = isNaN(parseInt(second)) ? Infinity : parseInt(second);\n    const min = first <= second ? first : second;\n    const max = second >= first ? second : first;\n    if (typeof value === 'string' || Array.isArray(value)) {\n        return value.length >= min && value.length <= max;\n    }\n    else if (value && typeof value === 'object') {\n        const length = Object.keys(value).length;\n        return length >= min && length <= max;\n    }\n    return false;\n};\n\n/**\n * Determine if the given input's value matches one or more values or regular expressions.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst matches = function matches({ value }, ...stack) {\n    return stack.some((pattern) => {\n        if (typeof pattern === 'string' &&\n            pattern.substr(0, 1) === '/' &&\n            pattern.substr(-1) === '/') {\n            pattern = new RegExp(pattern.substr(1, pattern.length - 2));\n        }\n        if (pattern instanceof RegExp) {\n            return pattern.test(String(value));\n        }\n        return pattern === value;\n    });\n};\n\n/**\n * Determine if the given input's value is less than the maximum\n * @param context - The FormKitValidationContext\n * @public\n */\nconst max = function max({ value }, maximum = 10) {\n    if (Array.isArray(value)) {\n        return value.length <= maximum;\n    }\n    return Number(value) <= Number(maximum);\n};\n\n/**\n * Determine if the given input's value is less than a certain value.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst min = function min({ value }, minimum = 1) {\n    if (Array.isArray(value)) {\n        return value.length >= minimum;\n    }\n    return Number(value) >= Number(minimum);\n};\n\n/**\n * Determine if the given input's value is not in a given stack\n * @param context - The FormKitValidationContext\n * @public\n */\nconst not = function not({ value }, ...stack) {\n    return !stack.some((item) => {\n        if (typeof item === 'object') {\n            return eq(item, value);\n        }\n        return item === value;\n    });\n};\n\n/**\n * Determine if the given input's value is numeric\n * @param context - The FormKitValidationContext\n * @public\n */\nconst number = function number({ value }) {\n    return !isNaN(value);\n};\n\n/**\n * Determine if the given input's value was required.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst required = function required({ value }) {\n    return !empty(value);\n};\n/**\n * This rules should run even if the inputs is empty (obviously)\n */\nrequired.skipEmpty = false;\n\n/**\n * Determine if the given input's value starts with a substring\n * @param context - The FormKitValidationContext\n * @public\n */\nconst starts_with = function starts_with({ value }, ...stack) {\n    if (typeof value === 'string' && stack.length) {\n        return stack.some((item) => {\n            return value.startsWith(item);\n        });\n    }\n    else if (typeof value === 'string' && stack.length === 0) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * Determine if the given input's value is an http url\n * @param context - The FormKitValidationContext\n * @public\n */\nconst url = function url({ value }, ...stack) {\n    try {\n        const protocols = stack.length ? stack : ['http:', 'https:'];\n        const url = new URL(String(value));\n        return protocols.includes(url.protocol);\n    }\n    catch {\n        return false;\n    }\n};\n\nexport { accepted, alpha, alpha_spaces, alphanumeric, between, confirm, date_after, date_before, date_between, date_format, email, ends_with, is, length, matches, max, min, not, number, required, starts_with, url };\n", "import { has } from '@formkit/utils';\nimport { isNode } from '@formkit/core';\n\n/**\n * The FormKitNode to observe.\n * @param node - Any formkit node to observe.\n * @returns\n * @public\n */\nfunction createObserver(node, dependencies) {\n    // The dependencies touched during tracking\n    const deps = dependencies || Object.assign(new Map(), { active: false });\n    // A registry of event receipts returned by the event system\n    const receipts = new Map();\n    /**\n     * Simple function to add a dependency to the deps map.\n     * @param event - The name of the event type (like commit/input etc)\n     */\n    const addDependency = function (event) {\n        var _a;\n        if (!deps.active)\n            return;\n        if (!deps.has(node))\n            deps.set(node, new Set());\n        (_a = deps.get(node)) === null || _a === void 0 ? void 0 : _a.add(event);\n    };\n    /**\n     * Proxies the props of a node so we know which ones were messed with, could\n     * potentially be more generalized in the future if we want to support\n     * more sub-objects.\n     * @param props - The props object from a node\n     * @returns\n     */\n    const observeProps = function (props) {\n        return new Proxy(props, {\n            get(...args) {\n                typeof args[1] === 'string' && addDependency(`prop:${args[1]}`);\n                return Reflect.get(...args);\n            },\n        });\n    };\n    /**\n     * Observes the FormKit ledger \"value\".\n     * @param ledger - A formkit ledger counter.\n     */\n    const observeLedger = function (ledger) {\n        return new Proxy(ledger, {\n            get(...args) {\n                if (args[1] === 'value') {\n                    return (key) => {\n                        addDependency(`count:${key}`);\n                        return ledger.value(key);\n                    };\n                }\n                return Reflect.get(...args);\n            },\n        });\n    };\n    /**\n     * Return values from our observer proxy first pass through this function\n     * which gives us a chance to listen sub-dependencies and properties.\n     */\n    const observe = function (value, property) {\n        if (isNode(value)) {\n            return createObserver(value, deps);\n        }\n        if (property === 'value')\n            addDependency('commit');\n        if (property === 'props')\n            return observeProps(value);\n        if (property === 'ledger')\n            return observeLedger(value);\n        return value;\n    };\n    /**\n     * The actual proxy object of the original node.\n     */\n    const { proxy: observed, revoke, } = Proxy.revocable(node, {\n        get(...args) {\n            switch (args[1]) {\n                case 'deps':\n                    return deps;\n                case 'watch':\n                    return (block) => watch(observed, block);\n                case 'observe':\n                    return () => {\n                        const old = new Map(deps);\n                        deps.clear();\n                        deps.active = true;\n                        return old;\n                    };\n                case 'stopObserve':\n                    return () => {\n                        const newDeps = new Map(deps);\n                        deps.active = false;\n                        return newDeps;\n                    };\n                case 'receipts':\n                    return receipts;\n                case 'kill':\n                    removeListeners(receipts);\n                    return () => revoke();\n            }\n            const value = Reflect.get(...args);\n            // If we're dealing with a function, we need to sub-call the function\n            // get that return value, and pass it through the same logic.\n            if (typeof value === 'function') {\n                return (...subArgs) => {\n                    const subValue = value(...subArgs);\n                    return observe(subValue, args[1]);\n                };\n            }\n            return observe(value, args[1]);\n        },\n    });\n    return observed;\n}\n/**\n * Given two maps (toAdd and toRemove) apply the dependencies as event listeners\n * on the underlying nodes.\n * @param node - The node to apply dependencies to\n * @param delta - The toAdd and toRemove dependency Maps\n * @public\n */\nfunction applyListeners(node, [toAdd, toRemove], callback) {\n    toAdd.forEach((events, depNode) => {\n        events.forEach((event) => {\n            node.receipts.has(depNode) || node.receipts.set(depNode, {});\n            node.receipts.set(depNode, Object.assign(node.receipts.get(depNode), {\n                [event]: depNode.on(event, callback),\n            }));\n        });\n    });\n    toRemove.forEach((events, depNode) => {\n        events.forEach((event) => {\n            if (node.receipts.has(depNode)) {\n                const nodeReceipts = node.receipts.get(depNode);\n                if (nodeReceipts && has(nodeReceipts, event)) {\n                    depNode.off(nodeReceipts[event]);\n                    delete nodeReceipts[event];\n                    node.receipts.set(depNode, nodeReceipts);\n                }\n            }\n        });\n    });\n}\n/**\n * Remove all the receipts from the observed node and subtree.\n * @param receipts - The formkit observer receipts to remove\n * @public\n */\nfunction removeListeners(receipts) {\n    receipts.forEach((events, node) => {\n        for (const event in events) {\n            node.off(events[event]);\n        }\n    });\n}\n/**\n * Observes a chunk of code to dependencies, and then re-calls that chunk of\n * code when those dependencies are manipulated.\n * @param node - The node to observer\n * @param block - The block of code to observe\n * @public\n */\nasync function watch(node, block) {\n    const oldDeps = new Map(node.deps);\n    node.observe();\n    const res = block(node);\n    if (res instanceof Promise)\n        await res;\n    const newDeps = node.stopObserve();\n    applyListeners(node, diffDeps(oldDeps, newDeps), () => watch(node, block));\n}\n/**\n * Determines which nodes should be added as dependencies and which should be\n * removed.\n * @param previous - The previous watcher dependencies\n * @param current - The new/current watcher dependencies\n * @returns\n * @public\n */\nfunction diffDeps(previous, current) {\n    const toAdd = new Map();\n    const toRemove = new Map();\n    current.forEach((events, node) => {\n        if (!previous.has(node)) {\n            toAdd.set(node, events);\n        }\n        else {\n            const eventsToAdd = new Set();\n            const previousEvents = previous.get(node);\n            events.forEach((event) => !(previousEvents === null || previousEvents === void 0 ? void 0 : previousEvents.has(event)) && eventsToAdd.add(event));\n            toAdd.set(node, eventsToAdd);\n        }\n    });\n    previous.forEach((events, node) => {\n        if (!current.has(node)) {\n            toRemove.set(node, events);\n        }\n        else {\n            const eventsToRemove = new Set();\n            const newEvents = current.get(node);\n            events.forEach((event) => !(newEvents === null || newEvents === void 0 ? void 0 : newEvents.has(event)) && eventsToRemove.add(event));\n            toRemove.set(node, eventsToRemove);\n        }\n    });\n    return [toAdd, toRemove];\n}\n\nexport { applyListeners, createObserver, diffDeps, removeListeners };\n", "import { createMessage } from '@formkit/core';\nimport { createObserver, removeListeners, applyListeners, diffDeps } from '@formkit/observer';\nimport { token, empty, clone, has } from '@formkit/utils';\n\n/**\n * Message that gets set when the node is awaiting validation.\n */\nconst validatingMessage = createMessage({\n    type: 'state',\n    blocking: true,\n    visible: false,\n    value: true,\n    key: 'validating',\n});\n/**\n * The actual validation plugin function, everything must be bootstrapped here.\n * @param node - The node to bind validation to.\n * @public\n */\nfunction createValidationPlugin(baseRules = {}) {\n    return function validationPlugin(node) {\n        const availableRules = Object.assign({}, baseRules, node.props.validationRules);\n        // create an observed node\n        const observedNode = createObserver(node);\n        const state = { input: token(), rerun: null, isPassing: true };\n        // If the node's validation prop changes, update the rules:\n        node.on('prop', (event) => {\n            if (event.payload.prop === 'validation') {\n                // Destroy all observers that may re-trigger validation on an old stack\n                removeListeners(observedNode.receipts);\n                // Remove all existing messages before re-validating\n                node.store.filter(() => false, 'validation');\n                node.props.parsedRules = parseRules(event.payload.value, availableRules);\n                validate(observedNode, node.props.parsedRules, state);\n            }\n        });\n        // Validate the field when this plugin is initialized\n        node.props.parsedRules = parseRules(node.props.validation, availableRules);\n        validate(observedNode, node.props.parsedRules, state);\n    };\n}\n/**\n * Given parsed validations, a value and a node, run the validations and set\n * the appropriate store messages on the node.\n * @param value - The value being validated\n * @param node - The Node this value belongs to\n * @param rules - The rules\n */\nfunction validate(node, validations, state) {\n    state.input = token();\n    state.isPassing = true;\n    node.store.filter((message) => !message.meta.removeImmediately, 'validation');\n    validations.forEach((validation) => validation.debounce && clearTimeout(validation.timer));\n    if (validations.length) {\n        node.store.set(validatingMessage);\n        run(0, validations, node, state, false, () => {\n            node.store.remove(validatingMessage.key);\n        });\n    }\n}\n/**\n * Runs validation rules recursively while collecting dependencies allowing for\n * cross-node validation rules that automatically re-trigger when a foreign\n * value is changed.\n * @param current - The index of the current validation rule\n * @param validations - The remaining validation rule stack to run\n * @param node - An observed node, the owner of this validation stack\n * @param state - An object of state information about this run\n * @param removeImmediately - Should messages created during this call be removed immediately when a new commit takes place?\n * @returns\n */\nfunction run(current, validations, node, state, removeImmediately, complete) {\n    const validation = validations[current];\n    if (!validation)\n        return complete();\n    const currentRun = state.input;\n    validation.state = null;\n    function next(async, result) {\n        state.isPassing = state.isPassing && !!result;\n        validation.queued = false;\n        const newDeps = node.stopObserve();\n        applyListeners(node, diffDeps(validation.deps, newDeps), () => {\n            validation.queued = true;\n            if (state.rerun)\n                clearTimeout(state.rerun);\n            state.rerun = setTimeout(validate, 0, node, validations, state);\n        });\n        validation.deps = newDeps;\n        if (state.input === currentRun) {\n            validation.state = result;\n            if (result === false) {\n                createFailedMessage(node, validation, removeImmediately || async);\n            }\n            else {\n                removeMessage(node, validation);\n            }\n            if (validations.length > current + 1) {\n                run(current + 1, validations, node, state, removeImmediately || async, complete);\n            }\n            else {\n                // The validation has completed\n                complete();\n            }\n        }\n    }\n    if ((!empty(node.value) || !validation.skipEmpty) &&\n        (state.isPassing || validation.force)) {\n        if (validation.queued) {\n            runRule(validation, node, (result) => {\n                result instanceof Promise\n                    ? result.then((r) => next(true, r))\n                    : next(false, result);\n            });\n        }\n        else {\n            // In this case our rule is not queued, so literally nothing happened that\n            // would affect it, we just need to move past this rule and make no\n            // modifications to state\n            run(current + 1, validations, node, state, removeImmediately, complete);\n        }\n    }\n    else {\n        // This rule is not being run because either:\n        //  1. The field is empty and this rule should not run when empty\n        //  2. A previous validation rule is failing and this one is not forced\n        // In this case we should call next validation.\n        if (empty(node.value) && validation.skipEmpty && state.isPassing) {\n            // This node has an empty value so its validation was skipped. So we\n            // need to queue it up, we do that by starting an observation and just\n            // touching the value attribute.\n            node.observe();\n            node.value;\n        }\n        next(false, null);\n    }\n}\n/**\n * Run a validation rule debounced or not.\n * @param validation - A validation to debounce\n */\nfunction runRule(validation, node, after) {\n    if (validation.debounce) {\n        validation.timer = setTimeout(() => {\n            node.observe();\n            after(validation.rule(node, ...validation.args));\n        }, validation.debounce);\n    }\n    else {\n        node.observe();\n        after(validation.rule(node, ...validation.args));\n    }\n}\n/**\n * The messages given to this function have already been set on the node, but\n * any other validation messages on the node that are not included in this\n * stack should be removed because they have been resolved.\n * @param node - The node to operate on.\n * @param messages - A new stack of messages\n */\nfunction removeMessage(node, validation) {\n    const key = `rule_${validation.name}`;\n    if (has(node.store, key)) {\n        node.store.remove(key);\n    }\n}\n/**\n *\n * @param value - The value that is failing\n * @param validation - The validation object\n */\nfunction createFailedMessage(node, validation, removeImmediately) {\n    const i18nArgs = createI18nArgs(node, validation);\n    const customMessage = createCustomMessage(node, validation, i18nArgs);\n    // Here we short circuit the i18n system to force the output.\n    const message = createMessage({\n        blocking: validation.blocking,\n        key: `rule_${validation.name}`,\n        meta: {\n            /**\n             * Use this key instead of the message root key to produce i18n validation\n             * messages.\n             */\n            messageKey: validation.name,\n            /**\n             * For messages that were created *by or after* a debounced or async\n             * validation rule \u2014 we make note of it so we can immediately remove them\n             * as soon as the next commit happens.\n             */\n            removeImmediately,\n            /**\n             * Determines if this message should be passed to localization.\n             */\n            localize: !customMessage,\n            /**\n             * The arguments that will be passed to the validation rules\n             */\n            i18nArgs,\n        },\n        type: 'validation',\n        value: customMessage || 'This field is not valid.',\n    });\n    node.store.set(message);\n    return message;\n}\n/**\n * Returns a custom validation message if applicable.\n * @param node - FormKit Node\n * @param validation - The validation rule being processed.\n */\nfunction createCustomMessage(node, validation, i18nArgs) {\n    const customMessage = node.props.validationMessages &&\n        has(node.props.validationMessages, validation.name)\n        ? node.props.validationMessages[validation.name]\n        : undefined;\n    if (typeof customMessage === 'function') {\n        return customMessage(...i18nArgs);\n    }\n    return customMessage;\n}\n/**\n * Creates the arguments passed to the i18n\n * @param node - The node that performed the validation\n * @param validation - The validation that failed\n */\nfunction createI18nArgs(node, validation) {\n    // If a custom message has been found, short circuit the i18n system.\n    return [\n        {\n            node,\n            name: createMessageName(node),\n            args: validation.args,\n        },\n    ];\n}\n/**\n * The name used in validation messages.\n * @param node - The node to display\n * @returns\n */\nfunction createMessageName(node) {\n    if (typeof node.props.validationLabel === 'function') {\n        return node.props.validationLabel(node);\n    }\n    return (node.props.validationLabel ||\n        node.props.label ||\n        node.props.name ||\n        String(node.name));\n}\n/**\n * Describes hints, must also be changed in the debounceExtractor.\n */\nconst hintPattern = '(?:[\\\\*+?()0-9]+)';\n/**\n * A pattern to describe rule names. Rules names can only contain letters,\n * numbers, and underscores and must start with a letter.\n */\nconst rulePattern = '[a-zA-Z][a-zA-Z0-9_]+';\n/**\n * Regular expression for extracting rule data.\n */\nconst ruleExtractor = new RegExp(`^(${hintPattern}?${rulePattern})(?:\\\\:(.*)+)?$`, 'i');\n/**\n * Validation hints are special characters preceding a validation rule, like\n * !phone\n */\nconst hintExtractor = new RegExp(`^(${hintPattern})(${rulePattern})$`, 'i');\n/**\n * Given a hint string like ^(200)? or ^? or (200)?^ extract the hints to\n * matches.\n */\nconst debounceExtractor = /([\\*+?]+)?(\\(\\d+\\))([\\*+?]+)?/;\n/**\n * Determines if a given string is in the proper debounce format.\n */\nconst hasDebounce = /\\(\\d+\\)/;\n/**\n * The default values of the available validation hints.\n */\nconst defaultHints = {\n    blocking: true,\n    debounce: 0,\n    force: false,\n    skipEmpty: true,\n    name: '',\n};\n/**\n * Parse validation intents and strings into validation rule stacks.\n * @param validation - Either a string a validation rules, or proper array of structured rules.\n * @internal\n */\nfunction parseRules(validation, rules) {\n    if (!validation)\n        return [];\n    const intents = typeof validation === 'string'\n        ? extractRules(validation)\n        : clone(validation);\n    return intents.reduce((validations, args) => {\n        let rule = args.shift();\n        const hints = {};\n        if (typeof rule === 'string') {\n            const [ruleName, parsedHints] = parseHints(rule);\n            if (has(rules, ruleName)) {\n                rule = rules[ruleName];\n                Object.assign(hints, parsedHints);\n            }\n        }\n        if (typeof rule === 'function') {\n            validations.push({\n                rule,\n                args,\n                timer: 0,\n                state: null,\n                queued: true,\n                deps: new Map(),\n                ...defaultHints,\n                ...fnHints(hints, rule),\n            });\n        }\n        return validations;\n    }, []);\n}\n/**\n * A string of validation rules written in FormKitRule notation.\n * @param validation - The string of rules\n * @internal\n */\nfunction extractRules(validation) {\n    return validation.split('|').reduce((rules, rule) => {\n        const parsedRule = parseRule(rule);\n        if (parsedRule) {\n            rules.push(parsedRule);\n        }\n        return rules;\n    }, []);\n}\n/**\n * Given a rule like confirm:password_confirm produce a FormKitValidationIntent\n * @param rule - A string representing a validation rule.\n * @returns\n */\nfunction parseRule(rule) {\n    const trimmed = rule.trim();\n    if (trimmed) {\n        const matches = trimmed.match(ruleExtractor);\n        if (matches && typeof matches[1] === 'string') {\n            const ruleName = matches[1].trim();\n            const args = matches[2] && typeof matches[2] === 'string'\n                ? matches[2].split(',').map((s) => s.trim())\n                : [];\n            return [ruleName, ...args];\n        }\n    }\n    return false;\n}\n/**\n * Given a rule name, detect if there are any additional hints like !\n * @param ruleName - string representing a rule name\n * @returns\n */\nfunction parseHints(ruleName) {\n    const matches = ruleName.match(hintExtractor);\n    if (!matches) {\n        return [ruleName, { name: ruleName }];\n    }\n    const map = {\n        '*': { force: true },\n        '+': { skipEmpty: false },\n        '?': { blocking: false },\n    };\n    const [, hints, rule] = matches;\n    const hintGroups = hasDebounce.test(hints)\n        ? hints.match(debounceExtractor) || []\n        : [, hints];\n    return [\n        rule,\n        [hintGroups[1], hintGroups[2], hintGroups[3]].reduce((hints, group) => {\n            if (!group)\n                return hints;\n            if (hasDebounce.test(group)) {\n                hints.debounce = parseInt(group.substr(1, group.length - 1));\n            }\n            else {\n                group\n                    .split('')\n                    .forEach((hint) => has(map, hint) && Object.assign(hints, map[hint]));\n            }\n            return hints;\n        }, { name: rule }),\n    ];\n}\n/**\n * Extracts hint properties from the validation rule function itself and applies\n * them if they are not already in the set of validation hints extracted from\n * strings.\n * @param existingHints - An existing set of hints already parsed\n * @param rule - The actual rule function, which can contain hint properties\n * @returns\n */\nfunction fnHints(existingHints, rule) {\n    if (!existingHints.name) {\n        existingHints.name = rule.ruleName || rule.name;\n    }\n    return ['skipEmpty', 'force', 'debounce', 'blocking'].reduce((hints, hint) => {\n        if (has(rule, hint) && !has(hints, hint)) {\n            Object.assign(hints, {\n                [hint]: rule[hint],\n            });\n        }\n        return hints;\n    }, existingHints);\n}\n\nexport { createValidationPlugin };\n", "import { has } from '@formkit/utils';\n\n/**\n * Given a string, convert it to sentence case.\n * @param item - The string to sentence case\n * @returns\n * @public\n */\nfunction sentence(str) {\n    return str[0].toUpperCase() + str.substr(1);\n}\n/**\n * Creates an oxford-comma separated list of items.\n * @param args - items to list out\n * @param conjunction - in: x, y, and z \"and\" is the conjunction to use\n * @returns\n * @public\n */\nfunction list(items, conjunction = 'or') {\n    return items.reduce((oxford, item, index) => {\n        oxford += item;\n        if (index <= items.length - 2 && items.length > 2) {\n            oxford += ', ';\n        }\n        if (index === items.length - 2) {\n            oxford += `${items.length === 2 ? ' ' : ''}${conjunction} `;\n        }\n        return oxford;\n    }, '');\n}\n/**\n * Given a string or a date return a nice human-readable version.\n * @param date - A string or a date.\n * @public\n */\nfunction date(date) {\n    const dateTime = typeof date === 'string' ? new Date(Date.parse(date)) : date;\n    if (!(dateTime instanceof Date)) {\n        return '(unknown)';\n    }\n    return new Intl.DateTimeFormat(undefined, {\n        dateStyle: 'medium',\n    }).format(dateTime);\n}\n/**\n * Orders two variables smallest to largest.\n * @param first - first argument\n * @param second - Second argument\n * @returns\n * @public\n */\nfunction order(first, second) {\n    return Number(first) >= Number(second) ? [second, first] : [first, second];\n}\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$l = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: '\u0625\u0632\u0627\u0644\u0629',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: '\u0625\u0632\u0627\u0644\u0629 \u0627\u0644\u0643\u0644',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: '\u0639\u0630\u0631\u0627\u060C \u0644\u0645 \u064A\u062A\u0645 \u062A\u0639\u0628\u0626\u0629 \u062C\u0645\u064A\u0639 \u0627\u0644\u062D\u0642\u0648\u0644 \u0628\u0634\u0643\u0644 \u0635\u062D\u064A\u062D.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: '\u0625\u0631\u0633\u0627\u0644',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: '\u0644\u0627 \u064A\u0648\u062C\u062F \u0645\u0644\u0641 \u0645\u062E\u062A\u0627\u0631',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$l = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `\u0627\u0644\u0631\u062C\u0627\u0621 \u0642\u0628\u0648\u0644 ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0628\u0639\u062F ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0641\u064A \u0627\u0644\u0645\u0633\u062A\u0642\u0628\u0644.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `\u064A\u0645\u0643\u0646 \u0623\u0646 \u064A\u062D\u062A\u0648\u064A ${sentence(name)} \u0639\u0644\u0649 \u0623\u062D\u0631\u0641 \u0623\u0628\u062C\u062F\u064A\u0629 \u0641\u0642\u0637.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `\u064A\u0645\u0643\u0646 \u0623\u0646 \u064A\u062D\u062A\u0648\u064A ${sentence(name)} \u0639\u0644\u0649 \u0623\u062D\u0631\u0641 \u0648\u0623\u0631\u0642\u0627\u0645 \u0641\u0642\u0637.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `\u064A\u0645\u0643\u0646 \u0623\u0646 \u062A\u062D\u062A\u0648\u064A ${sentence(name)} \u0639\u0644\u0649 \u0623\u062D\u0631\u0641 \u0648\u0645\u0633\u0627\u0641\u0627\u062A \u0641\u0642\u0637.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0642\u0628\u0644 ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0641\u064A \u0627\u0644\u0645\u0627\u0636\u064A.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `\u062A\u0645\u062A \u062A\u0647\u064A\u0626\u0629 \u0647\u0630\u0627 \u0627\u0644\u062D\u0642\u0644 \u0628\u0634\u0643\u0644 \u063A\u064A\u0631 \u0635\u062D\u064A\u062D \u0648\u0644\u0627 \u064A\u0645\u0643\u0646 \u0625\u0631\u0633\u0627\u0644\u0647.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0645\u0627 \u0628\u064A\u0646 ${a} \u0648 ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} \u063A\u064A\u0631 \u0645\u062A\u0637\u0627\u0628\u0642.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} \u0644\u064A\u0633 \u062A\u0627\u0631\u064A\u062E\u064B\u0627 \u0635\u0627\u0644\u062D\u064B\u0627 \u060C \u064A\u0631\u062C\u0649 \u0627\u0633\u062A\u062E\u062F\u0627\u0645 \u0627\u0644\u062A\u0646\u0633\u064A\u0642 ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return '\u062A\u0645\u062A \u062A\u0647\u064A\u0626\u0629 \u0647\u0630\u0627 \u0627\u0644\u062D\u0642\u0644 \u0628\u0634\u0643\u0644 \u063A\u064A\u0631 \u0635\u062D\u064A\u062D \u0648\u0644\u0627 \u064A\u0645\u0643\u0646 \u0625\u0631\u0633\u0627\u0644\u0647';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0628\u064A\u0646 ${date(args[0])} \u0648 ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: '\u0627\u0644\u0631\u062C\u0627\u0621 \u0623\u062F\u062E\u0627\u0644 \u0628\u0631\u064A\u062F \u0625\u0644\u064A\u0643\u062A\u0631\u0648\u0646\u064A \u0635\u0627\u0644\u062D.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `\u0644\u0627 \u064A\u0646\u062A\u0647\u064A ${sentence(name)} \u0628\u0640 ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} \u0644\u064A\u0633\u062A \u0642\u064A\u0645\u0629 \u0645\u0633\u0645\u0648\u062D \u0628\u0647\u0627.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u062D\u0631\u0641\u064B\u0627 \u0648\u0627\u062D\u062F\u064B\u0627 \u0639\u0644\u0649 \u0627\u0644\u0623\u0642\u0644.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0623\u0642\u0644 \u0645\u0646 \u0623\u0648 \u064A\u0633\u0627\u0648\u064A ${max} \u062D\u0631\u0641\u064B\u0627.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0623\u0643\u0628\u0631 \u0645\u0646 \u0623\u0648 \u064A\u0633\u0627\u0648\u064A ${min} \u062D\u0631\u0641\u064B\u0627.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0628\u064A\u0646 ${min} \u0648 ${max} \u062D\u0631\u0641\u064B\u0627.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} \u0644\u064A\u0633\u062A \u0642\u064A\u0645\u0629 \u0645\u0633\u0645\u0648\u062D \u0628\u0647\u0627.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `\u0644\u0627 \u064A\u0645\u0643\u0646 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0623\u0643\u062B\u0631 \u0645\u0646 ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0623\u0642\u0644 \u0645\u0646 \u0623\u0648 \u064A\u0633\u0627\u0648\u064A ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '\u0644\u0627 \u064A\u0633\u0645\u062D \u0628\u062A\u0646\u0633\u064A\u0642\u0627\u062A \u0627\u0644\u0645\u0644\u0641\u0627\u062A.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0645\u0646 \u0627\u0644\u0646\u0648\u0639: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `\u0644\u0627 \u064A\u0645\u0643\u0646 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0623\u0642\u0644 \u0645\u0646 ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0639\u0644\u0649 \u0627\u0644\u0623\u0642\u0644 ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D \u0644\u064A\u0633 ${name} \u0645\u0633\u0645\u0648\u062D\u064B\u0627 \u0628\u0647.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} \u064A\u062C\u0628 \u0627\u0646 \u064A\u0643\u0648\u0646 \u0631\u0642\u0645\u0627\u064B`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} \u0645\u0637\u0644\u0648\u0628.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `\u0644\u0627 \u064A\u0628\u062F\u0623 ${sentence(name)} \u0628\u0640 ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `\u0627\u0644\u0631\u062C\u0627\u0621 \u062A\u0636\u0645\u064A\u0646 \u0639\u0646\u0648\u0627\u0646 \u0631\u0627\u0628\u0637 \u0635\u062D\u064A\u062D.`;\n        /* </i18n> */\n    },\n};\n\nvar ar = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$l,\n    validation: validation$l\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$k = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Odebrat',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Odebrat v\u0161e',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Pardon, ale ne v\u0161echna pole jsou vypln\u011Bna spr\u00E1vn\u011B.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Odeslat',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: '\u017D\u00E1dn\u00FD soubor nebyl vybr\u00E1n',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$k = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Pros\u00EDm, za\u0161krtn\u011Bte ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} mus\u00ED b\u00FDt po ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} mus\u00ED b\u00FDt v budoucnosti.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} m\u016F\u017Ee obsahovat pouze p\u00EDsmena.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} m\u016F\u017Ee obsahovat pouze p\u00EDsmena a \u010D\u00EDsla.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} mus\u00ED b\u00FDt p\u0159ed ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} mus\u00ED b\u00FDt v minulosti.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Toto pole bylo \u0161patn\u011B nakonfigurov\u00E1no a nem\u016F\u017Ee b\u00FDt odesl\u00E1no.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} mus\u00ED b\u00FDt mezi ${a} a ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} nejsou shodn\u00E1.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} nen\u00ED platn\u00E9 datum, pros\u00EDm, pou\u017Eijte form\u00E1t ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Toto pole bylo \u0161patn\u011B nakonfigurov\u00E1no a nem\u016F\u017Ee b\u00FDt odesl\u00E1no.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} mus\u00ED b\u00FDt mezi ${date(args[0])} a ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Pros\u00EDm, zadejte platnou e-mailovou adresu.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} nekon\u010D\u00ED na ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} nen\u00ED povolen\u00E1 hodnota.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} mus\u00ED m\u00EDt nejm\u00E9n\u011B jeden znak.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} m\u016F\u017Ee m\u00EDt maxim\u00E1ln\u011B ${max} znak\u016F.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} mus\u00ED obsahovat minim\u00E1ln\u011B ${min} znak\u016F.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} mus\u00ED b\u00FDt dlouh\u00E9 ${min} a\u017E ${max} znak\u016F.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} nen\u00ED povolen\u00E1 hodnota.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Nelze pou\u017E\u00EDt v\u00EDce ne\u017E ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} mus\u00ED m\u00EDt men\u0161\u00ED nebo rovno ne\u017E ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Nejsou nakonfigurov\u00E1ny povolen\u00E9 typy soubor\u016F.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} mus\u00ED b\u00FDt typu: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Nelze m\u00EDt m\u00E9n\u011B ne\u017E ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} mus\u00ED b\u00FDt minim\u00E1ln\u011B ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D nen\u00ED dovolen\u00E1 hodnota pro ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} mus\u00ED b\u00FDt \u010D\u00EDslo.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} je povinn\u00E9.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} neza\u010D\u00EDn\u00E1 na ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Zadejte, pros\u00EDm, platnou URL adresu.`;\n        /* </i18n> */\n    },\n};\n\nvar cs = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$k,\n    validation: validation$k\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$j = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Fjern',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Fjern alle',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Alle felter er ikke korrekt udfyldt.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Send',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Ingen filer valgt',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$j = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Accepter venligst ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} skal v\u00E6re senere end ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} skal v\u00E6re i fremtiden.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} kan kun indeholde bogstaver.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} kan kun indeholde bogstaver og tal.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} kan kun indeholde bogstaver og mellemrum.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} skal v\u00E6re f\u00F8r ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} skal v\u00E6re f\u00F8r i dag.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Dette felt er ikke konfigureret korrekt og kan derfor ikke blive sendt.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} skal v\u00E6re mellem ${a} og ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} matcher ikke.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} er ikke gyldig, brug venligst formatet ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Dette felt er ikke konfigureret korrekt og kan derfor ikke blive sendt.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} skal v\u00E6re mellem ${date(args[0])} og ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Indtast venligst en gyldig email-adresse.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} slutter ikke med ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} er ikke en gyldig v\u00E6rdi.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} skal v\u00E6re p\u00E5 mindst \u00E9t tegn.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} skal v\u00E6re p\u00E5 h\u00F8jst ${max} tegn.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} skal v\u00E6re p\u00E5 mindst ${min} tegn.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} skal v\u00E6re p\u00E5 mindst ${min} og h\u00F8jst ${max} tegn.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} er ikke en gyldig v\u00E6rdi.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Kan ikke have flere end ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} skal v\u00E6re mindre eller lig med ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Ingen filformater tilladt.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} skal v\u00E6re af filtypen: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Kan ikke have mindre end ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} skal v\u00E6re mindst ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D er ikke en tilladt ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} skal v\u00E6re et tal.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} er p\u00E5kr\u00E6vet.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} starter ikke med ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Indtast venligst en gyldig URL.`;\n        /* </i18n> */\n    },\n};\n\nvar da = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$j,\n    validation: validation$j\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$i = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Entfernen',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Alles entfernen',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Entschuldigung, nicht alle Felder wurden korrekt ausgef\u00FCllt.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Senden',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Keine Datei ausgew\u00E4hlt',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$i = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Bitte ${name} akzeptieren.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} muss nach dem ${date(args[0])} liegen.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} muss in der Zukunft liegen.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} darf nur Buchstaben enthalten.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} darf nur Buchstaben und Zahlen enthalten.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} d\u00FCrfen nur Buchstaben und Leerzeichen enthalten.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} muss vor dem ${date(args[0])} liegen.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} muss in der Vergangenheit liegen.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Dieses Feld wurde falsch konfiguriert und kann nicht \u00FCbermittelt werden.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} muss zwischen ${args[0]} und ${args[1]} sein.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} stimmt nicht \u00FCberein.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} ist kein g\u00FCltiges Datum im Format ${args[0]}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Dieses Feld wurde falsch konfiguriert und kann nicht \u00FCbermittelt werden.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} muss zwischen ${date(args[0])} und ${date(args[1])} liegen.`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'E-Mail Adresse ist ung\u00FCltig.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} endet nicht mit ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} enth\u00E4lt einen ung\u00FCltigen Wert.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} muss mindestens ein Zeichen enthalten.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} darf maximal ${max} Zeichen enthalten.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} muss mindestens ${min} Zeichen enthalten.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} muss zwischen ${min} und ${max} Zeichen enthalten.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} enth\u00E4lt einen ung\u00FCltigen Wert.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Darf maximal ${args[0]} ${name} haben.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} darf maximal ${args[0]} sein.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Keine Dateiformate konfiguriert.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} muss vom Typ ${args[0]} sein.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Mindestens ${args[0]} ${name} erforderlich.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} muss mindestens ${args[0]} sein.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D ist kein g\u00FCltiger Wert f\u00FCr ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} muss eine Zahl sein.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} ist erforderlich.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} beginnt nicht mit ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `URL ist ung\u00FCltig.`;\n        /* </i18n> */\n    },\n};\n\nvar de = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$i,\n    validation: validation$i\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$h = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Remove',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Remove all',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Sorry, not all fields are filled out correctly.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Submit',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'No file chosen',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$h = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Please accept the ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} must be after ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} must be in the future.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} can only contain alphabetical characters.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} can only contain letters and numbers.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} can only contain letters and spaces.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} must be before ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} must be in the past.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `This field was configured incorrectly and can\u2019t be submitted.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} must be between ${a} and ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} does not match.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} is not a valid date, please use the format ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'This field was configured incorrectly and can\u2019t be submitted';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} must be between ${date(args[0])} and ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Please enter a valid email address.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} doesn\u2019t end with ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} is not an allowed value.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} must be at least one character.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} must be less than or equal to ${max} characters.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} must be greater than or equal to ${min} characters.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} must be between ${min} and ${max} characters.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} is not an allowed value.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Cannot have more than ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} must be less than or equal to ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'No file formats allowed.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} must be of the type: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Cannot have less than ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} must be at least ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D is not an allowed ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} must be a number.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} is required.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} doesn\u2019t start with ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Please include a valid url.`;\n        /* </i18n> */\n    },\n};\n\nvar en = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$h,\n    validation: validation$h\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$g = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Quitar',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Quitar todos',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Disc\u00FAlpe, los campos no fueron completados correctamente.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Enviar',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Archivo no seleccionado',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$g = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Acepte el ${name} por favor.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} debe ser posterior a ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} debe ser una fecha futura.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} debe contener solo caract\u00E9res alfab\u00E9ticos.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} debe ser alfanum\u00E9rico.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} espacios alfa solo pueden contener letras y espacios.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} debe ser anterior a ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} debe ser una fecha pasada.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `El campo no fue completado correctamente y no puede ser enviado.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} debe estar entre ${a} y ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} no coincide.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} no es una fecha v\u00E1lida, por favor utilice el formato ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'El campo no fue completado correctamente y no puede ser enviado.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} debe estar entre ${date(args[0])} y ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Ingrese una direcci\u00F3n de correo electr\u00F3nico v\u00E1lida por favor.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} no termina con ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} no es un valor permitido.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} debe tener al menos una letra.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} debe tener como m\u00E1ximo ${max} caract\u00E9res.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} debe tener como m\u00EDnimo ${min} caract\u00E9res.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} debe tener entre ${min} y ${max} caract\u00E9res.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} no es un valor permitido.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Cannot have more than ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} debe ser menor o igual a ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'No existen formatos de archivos permitidos.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} debe ser del tipo: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Cannot have less than ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} debe ser de al menos ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D no es un valor permitido de ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} debe ser un n\u00FAmero.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} es requerido.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} debe comenzar con ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Proporcione una URL v\u00E1lida por favor.`;\n        /* </i18n> */\n    },\n};\n\nvar es = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$g,\n    validation: validation$g\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$f = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: '\u062D\u0630\u0641',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: '\u0647\u0645\u0647 \u0631\u0627 \u062D\u0630\u0641 \u06A9\u0646\u06CC\u062F',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: '\u0647\u0645\u0647 \u0641\u06CC\u0644\u062F\u0647\u0627 \u0628\u0647\u200C\u062F\u0631\u0633\u062A\u06CC \u067E\u0631 \u0646\u0634\u062F\u0647\u200C\u0627\u0646\u062F',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: '\u062B\u0628\u062A',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: '\u0647\u06CC\u0686 \u0641\u0627\u06CC\u0644\u06CC \u0627\u0646\u062A\u062E\u0627\u0628 \u0646\u0634\u062F\u0647 \u0627\u0633\u062A',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$f = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `\u0644\u0637\u0641\u0627\u064B ${name} \u0631\u0627 \u0628\u067E\u0630\u06CC\u0631\u06CC\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u0639\u062F \u0627\u0632 \u062A\u0627\u0631\u06CC\u062E ${date(args[0])} \u0628\u0627\u0634\u062F.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0645\u0631\u0628\u0648\u0637 \u0628\u0647 \u0622\u06CC\u0646\u062F\u0647 \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} \u0641\u0642\u0637 \u0645\u06CC\u062A\u0648\u0627\u0646\u062F \u0634\u0627\u0645\u0644 \u062D\u0631\u0648\u0641 \u0627\u0644\u0641\u0628\u0627 \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} \u0641\u0642\u0637 \u0645\u06CC\u062A\u0648\u0627\u0646\u062F \u0634\u0627\u0645\u0644 \u062D\u0631\u0648\u0641 \u0648 \u0627\u0639\u062F\u0627\u062F \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} \u0641\u0642\u0637 \u0645\u06CC \u062A\u0648\u0627\u0646\u062F \u0634\u0627\u0645\u0644 \u062D\u0631\u0648\u0641 \u0648 \u0641\u0627\u0635\u0644\u0647 \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0642\u0628\u0644 \u0627\u0632 \u062A\u0627\u0631\u06CC\u062E ${date(args[0])} \u0628\u0627\u0634\u062F.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0645\u0631\u0628\u0648\u0637 \u0628\u0647 \u06AF\u0630\u0634\u062A\u0647 \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `\u0627\u06CC\u0646 \u0641\u06CC\u0644\u062F \u0628\u0647 \u0627\u0634\u062A\u0628\u0627\u0647 \u067E\u06CC\u06A9\u0631\u0628\u0646\u062F\u06CC \u0634\u062F\u0647 \u0627\u0633\u062A \u0648 \u0642\u0627\u0628\u0644 \u0627\u0631\u0633\u0627\u0644 \u0646\u06CC\u0633\u062A`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u06CC\u0646 ${args[0]} \u0648 ${args[1]} \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} \u0645\u0637\u0627\u0628\u0642\u062A \u0646\u062F\u0627\u0631\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} \u062A\u0627\u0631\u06CC\u062E \u0645\u0639\u062A\u0628\u0631\u06CC \u0646\u06CC\u0633\u062A\u060C \u0644\u0637\u0641\u0627\u064B \u0627\u0632 \u0642\u0627\u0644\u0628 ${args[0]} \u0627\u0633\u062A\u0641\u0627\u062F\u0647 \u06A9\u0646\u06CC\u062F\n`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return '\u0627\u06CC\u0646 \u0641\u06CC\u0644\u062F \u0628\u0647 \u0627\u0634\u062A\u0628\u0627\u0647 \u067E\u06CC\u06A9\u0631\u0628\u0646\u062F\u06CC \u0634\u062F\u0647 \u0627\u0633\u062A \u0648 \u0642\u0627\u0628\u0644 \u0627\u0631\u0633\u0627\u0644 \u0646\u06CC\u0633\u062A';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u06CC\u0646 ${date(args[0])} \u0648 ${date(args[1])} \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: '\u0644\u0637\u0641\u0627 \u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644 \u0645\u0639\u062A\u0628\u0631 \u0648\u0627\u0631\u062F \u06A9\u0646\u06CC\u062F.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u0647 ${list(args)} \u062E\u062A\u0645 \u0634\u0648\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} \u0645\u062C\u0627\u0632 \u0646\u06CC\u0633\u062A.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} \u0628\u0627\u06CC\u062F \u062D\u062F\u0627\u0642\u0644 \u06CC\u06A9 \u06A9\u0627\u0631\u0627\u06A9\u062A\u0631 \u0628\u0627\u0634\u062F.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} \u0628\u0627\u06CC\u062F \u06A9\u0645\u062A\u0631 \u06CC\u0627 \u0628\u0631\u0627\u0628\u0631 \u0628\u0627 ${max} \u06A9\u0627\u0631\u0627\u06A9\u062A\u0631 \u0628\u0627\u0634\u062F.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u0632\u0631\u06AF\u062A\u0631 \u06CC\u0627 \u0628\u0631\u0627\u0628\u0631 \u0628\u0627 ${min} \u06A9\u0627\u0631\u0627\u06A9\u062A\u0631 \u0628\u0627\u0634\u062F.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u06CC\u0646 ${min} \u0648 ${max} \u06A9\u0627\u0631\u0627\u06A9\u062A\u0631 \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} \u0645\u062C\u0627\u0632 \u0646\u06CC\u0633\u062A.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `${name} \u0646\u0645\u06CC \u062A\u0648\u0627\u0646\u062F \u0628\u06CC\u0634 \u0627\u0632 ${args[0]} \u0628\u0627\u0634\u062F.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u06A9\u0645\u062A\u0631 \u06CC\u0627 \u0628\u0631\u0627\u0628\u0631 \u0628\u0627 ${args[0]} \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '\u0641\u0631\u0645\u062A \u0641\u0627\u06CC\u0644 \u0645\u062C\u0627\u0632 \u0646\u06CC\u0633\u062A.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0627\u0632 \u0627\u06CC\u0646 \u0646\u0648\u0639 \u0628\u0627\u0634\u062F: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `${name} \u0646\u0645\u06CC \u062A\u0648\u0627\u0646\u062F \u06A9\u0645\u062A\u0631 \u0627\u0632 ${args[0]} \u0628\u0627\u0634\u062F.\n`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u062D\u062F\u0627\u0642\u0644 ${args[0]} \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\"${value}\" \u06CC\u06A9 ${name} \u0645\u062C\u0627\u0632 \u0646\u06CC\u0633\u062A.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0639\u062F\u062F \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `\u067E\u0631 \u06A9\u0631\u062F\u0646 ${sentence(name)} \u0627\u062C\u0628\u0627\u0631\u06CC \u0627\u0633\u062A.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u0627 ${list(args)} \u0634\u0631\u0648\u0639 \u0634\u0648\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `\u0644\u0637\u0641\u0627\u064B \u0622\u062F\u0631\u0633 \u0627\u06CC\u0646\u062A\u0631\u0646\u062A\u06CC \u0645\u0639\u062A\u0628\u0631 \u0648\u0627\u0631\u062F \u06A9\u0646\u06CC\u062F.`;\n        /* </i18n> */\n    },\n};\n\nvar fa = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$f,\n    validation: validation$f\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$e = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Poista',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Poista kaikki',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Kaikkia kentti\u00E4 ei ole t\u00E4ytetty oikein.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Tallenna',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Ei valittuja tiedostoja',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$e = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Ole hyv\u00E4 ja hyv\u00E4ksy ${name}`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} tulee olla ${date(args[0])} j\u00E4lkeen.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} on oltava tulevaisuudessa.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} saa sis\u00E4lt\u00E4\u00E4 vain kirjaimia.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} saa sis\u00E4lt\u00E4\u00E4 vain kirjaimia ja numeroita.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} voivat sis\u00E4lt\u00E4\u00E4 vain kirjaimia ja v\u00E4lily\u00F6ntej\u00E4.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} tulee olla ennen: ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} on oltava menneisyydess\u00E4.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `T\u00E4m\u00E4 kentt\u00E4 on t\u00E4ytetty virheellisesti joten sit\u00E4 ei voitu l\u00E4hett\u00E4\u00E4.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} on oltava v\u00E4lill\u00E4 ${a} - ${b} `;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} ei t\u00E4sm\u00E4\u00E4.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} ei ole validi p\u00E4iv\u00E4m\u00E4\u00E4r\u00E4, ole hyv\u00E4 ja sy\u00F6t\u00E4 muodossa: ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'T\u00E4m\u00E4 kentt\u00E4 on t\u00E4ytetty virheellisesti joten sit\u00E4 ei voitu l\u00E4hett\u00E4\u00E4.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} on oltava v\u00E4lill\u00E4 ${date(args[0])} - ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Sy\u00F6t\u00E4 validi s\u00E4hk\u00F6postiosoite.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} tulee p\u00E4\u00E4tty\u00E4 ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} ei ole sallittu vaihtoehto.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} on oltava v\u00E4hint\u00E4\u00E4n yksi merkki.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} on oltava ${max} tai alle merkki\u00E4.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} on oltava v\u00E4hint\u00E4\u00E4n ${min} merkki\u00E4.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} on oltava v\u00E4hint\u00E4\u00E4n ${min}, enint\u00E4\u00E4n ${max} merkki\u00E4.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} ei ole sallittu arvo.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Valitse enint\u00E4\u00E4n ${args[0]} ${name} vaihtoehtoa.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} on oltava ${args[0]} tai alle.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Tiedostoja ei sallita.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} tulee olla ${args[0]}-tiedostotyyppi\u00E4.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Valitse v\u00E4hint\u00E4\u00E4n ${args[0]} ${name} vaihtoehtoa.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} tulee olla ${args[0]} tai suurempi.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D ei ole sallittu ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `Kent\u00E4n ${sentence(name)} tulee olla numero.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} vaaditaan.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} on alettava ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Sy\u00F6t\u00E4 validi url-osoite.`;\n        /* </i18n> */\n    },\n};\n\nvar fi = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$e,\n    validation: validation$e\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$d = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Supprimer',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Enlever tout',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'D\u00E9sol\u00E9, tous les champs ne sont pas remplis correctement.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Valider',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Aucun fichier choisi',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$d = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Veuillez accepter le ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} doit \u00EAtre post\u00E9rieure au ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} doit \u00EAtre dans le futur.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} ne peut contenir que des caract\u00E8res alphab\u00E9tiques.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} ne peut contenir que des lettres et des chiffres.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} ne peuvent contenir que des lettres et des espaces.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} doit \u00EAtre ant\u00E9rieure au ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} doit \u00EAtre dans le pass\u00E9.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Ce champ a \u00E9t\u00E9 configur\u00E9 de mani\u00E8re incorrecte et ne peut pas \u00EAtre soumis.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} doit \u00EAtre comprise entre ${a} et ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} ne correspond pas.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} n'est pas une date valide, veuillez utiliser le format ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Ce champ a \u00E9t\u00E9 configur\u00E9 de mani\u00E8re incorrecte et ne peut pas \u00EAtre soumis.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} doit \u00EAtre comprise entre ${date(args[0])} et ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Veuillez saisir une adresse email valide.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ne se termine pas par ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} n'est pas une valeur autoris\u00E9e.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} doit comporter au moins un caract\u00E8re.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} doit \u00EAtre inf\u00E9rieur ou \u00E9gal \u00E0 ${max} caract\u00E8res.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} doit \u00EAtre sup\u00E9rieur ou \u00E9gal \u00E0 ${min} caract\u00E8res.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} doit \u00EAtre comprise entre ${min} et ${max} caract\u00E8res.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} n'est pas une valeur autoris\u00E9e.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Ne peut pas avoir plus de ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} doit \u00EAtre inf\u00E9rieur ou \u00E9gal \u00E0 ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Aucun format de fichier n\u2019est autoris\u00E9';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} doit \u00EAtre du type: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Ne peut pas avoir moins de ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} doit \u00EAtre au moins de ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D n'est pas un ${name} autoris\u00E9.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} doit \u00EAtre un nombre.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} est requis.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ne commence pas par ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Veuillez saisir une url valide.`;\n        /* </i18n> */\n    },\n};\n\nvar fr = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$d,\n    validation: validation$d\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$c = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Ferwider',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Ferwider alles',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Sorry, net alle fjilden binne korrekt ynfolle.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Ferstjoere',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Gjin best\u00E2n keazen',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$c = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Akseptearje de ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} moat nei ${date(args[0])} w\u00EAze.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} moat yn de takomst lizze.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} mei allinne alfabetyske tekens befetsje.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} mei allinne letters en sifers befetsje.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} moat foar ${date(args[0])} falle.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} moat yn it ferline w\u00EAze.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Dit fjild is ferkeard konfigurearre en kin net ferstjoerd wurde.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} moat tusken ${a} en ${b} lizze.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} komt net oerien.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} is gjin jildige datum, br\u00FBk de notaasje ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Dit fjild is ferkeard konfigurearre en kin net ferstjoerd wurde';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} moat tusken ${date(args[0])} en ${date(args[1])} lizze`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Folje in jildich e-mailadres yn.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} einiget net mei ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} is gjin tastiene wearde.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} moat minimaal ien teken w\u00EAze.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} moat lytser w\u00EAze as of gelyk w\u00EAze oan ${max} tekens.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} moat grutter w\u00EAze as of gelyk w\u00EAze oan ${min} tekens.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} moat tusken de ${min} en ${max} tekens befetsje.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} is gjin tastiene wearde.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Mei net mear as ${args[0]} ${name} hawwe.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} moat lytser w\u00EAze as of gelyk w\u00EAze oan ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Gjin best\u00E2nsnotaasjes tastien.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} moat fan it type: ${args[0]} w\u00EAze`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Mei net minder as ${args[0]} ${name} hawwe.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} moat minimaal ${args[0]} w\u00EAze.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\"${value}\" is gjin tastiene ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} moat in getal w\u00EAze.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} is ferplicht.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} begjint net mei ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Doch der in jildige url by.`;\n        /* </i18n> */\n    },\n};\n\nvar fy = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$c,\n    validation: validation$c\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$b = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: '\u05DE\u05D7\u05E7',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: '\u05E9\u05D9\u05DD \u05DC\u05D1, \u05DC\u05D0 \u05DB\u05DC \u05D4\u05E9\u05D3\u05D5\u05EA \u05DE\u05DC\u05D0\u05D9\u05DD \u05DB\u05E8\u05D0\u05D5\u05D9.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: '\u05E9\u05DC\u05D7',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$b = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `\u05D0\u05E0\u05D0 \u05D0\u05E9\u05E8 \u05D0\u05EA ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05D0\u05D7\u05E8\u05D9 ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05D1\u05E2\u05EA\u05D9\u05D3.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05DB\u05D9\u05DC \u05D0\u05D5\u05EA\u05D9\u05D5\u05EA \u05D0\u05DC\u05E4\u05D1\u05EA.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05DB\u05D9\u05DC \u05E8\u05E7 \u05DE\u05E1\u05E4\u05E8\u05D9\u05DD \u05D5\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05DB\u05D9\u05DC \u05E8\u05E7 \u05D0\u05D5\u05EA\u05D9\u05D5\u05EA \u05D5\u05E8\u05D5\u05D5\u05D7\u05D9\u05DD.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DC\u05E4\u05E0\u05D9 ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05D1\u05E2\u05D1\u05E8`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `\u05E9\u05D3\u05D4 \u05D6\u05D4 \u05DC\u05D0 \u05D4\u05D5\u05D2\u05D3\u05E8 \u05DB\u05E8\u05D0\u05D5\u05D9 \u05D5\u05DC\u05D0 \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05D9\u05E9\u05DC\u05D7.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05D1\u05D9\u05DF ${args[0]} \u05D5-${args[1]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} \u05DC\u05D0 \u05DE\u05EA\u05D0\u05D9\u05DD.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} \u05D4\u05D5\u05D0 \u05DC\u05D0 \u05EA\u05D0\u05E8\u05D9\u05DA \u05EA\u05E7\u05D9\u05DF, \u05D0\u05E0\u05D0 \u05D4\u05E9\u05EA\u05DE\u05E9 \u05D1\u05E4\u05D5\u05E8\u05DE\u05D8 ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return '\u05E9\u05D3\u05D4 \u05D6\u05D4 \u05DC\u05D0 \u05D4\u05D5\u05D2\u05D3\u05E8 \u05DB\u05E8\u05D0\u05D5\u05D9 \u05D5\u05DC\u05D0 \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05D9\u05E9\u05DC\u05D7.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05D1\u05D9\u05DF ${date(args[0])} \u05D5- ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: '\u05D0\u05E0\u05D0 \u05D4\u05E7\u05DC\u05D3 \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC \u05EA\u05E7\u05D9\u05DF.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} \u05DC\u05D0 \u05DE\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1- ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} \u05D4\u05D5\u05D0 \u05DC\u05D0 \u05E2\u05E8\u05DA \u05DE\u05D5\u05E8\u05E9\u05D4.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DC\u05E4\u05D7\u05D5\u05EA \u05EA\u05D5 \u05D0\u05D7\u05D3.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05E4\u05D7\u05D5\u05EA \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC- ${max} \u05EA\u05D5\u05D5\u05D9\u05DD.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D9\u05D5\u05EA \u05D2\u05D3\u05D5\u05DC \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC- ${min} \u05EA\u05D5\u05D5\u05D9\u05DD.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05D1\u05D9\u05DF ${min} \u05D5- ${max} \u05EA\u05D5\u05D5\u05D9\u05DD.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} \u05D4\u05D5\u05D0 \u05DC\u05D0 \u05E2\u05E8\u05DA \u05EA\u05E7\u05D9\u05DF.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `${name} \u05DC\u05D0 \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05D9\u05D5\u05EA \u05E2\u05DD \u05D9\u05D5\u05EA\u05E8 \u05DE- ${args[0]}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05E4\u05D7\u05D5\u05EA \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC- ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '\u05E4\u05D5\u05E8\u05DE\u05D8 \u05D4\u05E7\u05D5\u05D1\u05E5 \u05DC\u05D0 \u05DE\u05D5\u05E8\u05E9\u05D4.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05E1\u05D5\u05D2: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `${name} \u05DC\u05D0 \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05D9\u05D5\u05EA \u05E2\u05DD \u05E4\u05D7\u05D5\u05EA \u05DE- ${args[0]}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DC\u05E4\u05D7\u05D5\u05EA ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D \u05DC\u05D0 \u05DE\u05EA\u05D0\u05D9\u05DD \u05DC- ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05E1\u05E4\u05E8.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} \u05D4\u05D9\u05E0\u05D5 \u05D7\u05D5\u05D1\u05D4.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} \u05DC\u05D0 \u05DE\u05EA\u05D7\u05D9\u05DC \u05D1- ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `\u05D0\u05E0\u05D0 \u05D4\u05E7\u05DC\u05D3 \u05E7\u05D9\u05E9\u05D5\u05E8 \u05EA\u05E7\u05D9\u05DF.`;\n        /* </i18n> */\n    },\n};\n\nvar he = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$b,\n    validation: validation$b\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$a = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Ukloni',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Pojedina polja nisu ispravno ispunjena.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Predaj',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$a = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Potrebno je potvrditi ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} mora biti u periodu poslije ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} mora biti u budu\u0107nosti.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} mora sadr\u017Eavati samo slova.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} mora sadr\u017Eavati slova i brojeve.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} mogu sadr\u017Eavati samo slova i razmake..`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} mora biti prije ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} mora biti u pro\u0161losti.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Format sadr\u017Eaja nije ispravan i ne mo\u017Ee biti predan.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} mora biti izme\u0111u ${args[0]} i ${args[1]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} ne odgovara zadanoj vrijednosti.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} nije ispravan format datuma. Molimo koristite sljede\u0107i format: ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Ovo polje nije ispravno postavljeno i ne mo\u017Ee biti predano.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} mora biti vrijednost izme\u0111u ${date(args[0])} i ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Molimo upi\u0161ite ispravnu email adresu.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ne zavr\u0161ava s ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} nije dopu\u0161tena vrijednost.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} mora sadr\u017Eavati barem jedan znak.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} mora imati ${max} ili manje znakova.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} mora imati barem ${min} znakova.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `Broj znakova za polje ${sentence(name)} mora biti izme\u0111u ${min} i ${max}.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} nije dozvoljena vrijednost.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Ne smije imati vi\u0161e od ${args[0]} ${name} polja.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} mora imati vrijednost manju ili jednaku ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Format datoteke nije dozvoljen.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `Format datoteke na polju ${sentence(name)} mora odgovarati: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Broj upisanih vrijednosti na polju ${name} mora biti barem ${args[0]}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} mora biti barem ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D nije dozvoljena vrijednost na polju ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} mora biti broj.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} je obavezno.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ne po\u010Dinje s ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Molimo unesite ispravnu poveznicu.`;\n        /* </i18n> */\n    },\n};\n\nvar hr = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$a,\n    validation: validation$a\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$9 = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: '\uC81C\uAC70',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: '\uBAA8\uB450 \uC81C\uAC70',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: '\uBAA8\uB4E0 \uAC12\uC744 \uCC44\uC6CC\uC8FC\uC138\uC694',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: '\uC81C\uCD9C\uD558\uAE30',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: '\uC120\uD0DD\uB41C \uD30C\uC77C\uC774 \uC5C6\uC2B5\uB2C8\uB2E4',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$9 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `${name} \uC62C\uBC14\uB978 \uAC12\uC744 \uC120\uD0DD \uD574\uC8FC\uC138\uC694`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} ${date(args[0])} \uC774\uD6C4\uC5EC\uC57C \uD569\uB2C8\uB2E4`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} \uBBF8\uB798\uC758 \uB0A0\uC9DC\uC5EC\uC57C\uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} \uC54C\uD30C\uBCB3 \uBB38\uC790\uB9CC \uD3EC\uD568\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} \uBB38\uC790\uC640 \uC22B\uC790\uB9CC \uD3EC\uD568\uB420 \uC218 \uC788\uC2B5\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} \uBB38\uC790\uC640 \uACF5\uBC31\uB9CC \uD3EC\uD568\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} ${date(args[0])} \uC774\uC804\uC5EC\uC57C \uD569\uB2C8\uB2E4`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} \uACFC\uAC70\uC758 \uB0A0\uC9DC\uC5EC\uC57C\uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `\uC798\uBABB\uB41C \uAD6C\uC131\uC73C\uB85C \uC81C\uCD9C\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} ${a}\uC640 ${b} \uC0AC\uC774\uC5EC\uC57C \uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} \uC77C\uCE58\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} \uC720\uD6A8\uD55C \uB0A0\uC9DC\uAC00 \uC544\uB2D9\uB2C8\uB2E4. ${args[0]}\uACFC \uAC19\uC740 \uD615\uC2DD\uC744 \uC0AC\uC6A9\uD574\uC8FC\uC138\uC694`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return '\uC798\uBABB\uB41C \uAD6C\uC131\uC73C\uB85C \uC81C\uCD9C\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} ${date(args[0])}\uC5D0\uC11C ${date(args[1])} \uC0AC\uC774\uC5EC\uC57C \uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: '\uC62C\uBC14\uB978 \uC774\uBA54\uC77C \uC8FC\uC18C\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ${list(args)}\uB85C \uB05D\uB098\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} \uD5C8\uC6A9\uB418\uB294 \uAC12\uC774 \uC544\uB2D9\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} \uD558\uB098 \uC774\uC0C1\uC758 \uBB38\uC790\uC5EC\uC57C \uD569\uB2C8\uB2E4`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} ${max}\uC790 \uC774\uD558\uC5EC\uC57C \uD569\uB2C8\uB2E4`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} ${min} \uBB38\uC790\uBCF4\uB2E4 \uD06C\uAC70\uB098 \uAC19\uC544\uC57C \uD569\uB2C8\uB2E4`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} ${min}\uC5D0\uC11C ${max}\uC790 \uC0AC\uC774\uC5EC\uC57C \uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} \uD5C8\uC6A9\uB418\uB294 \uAC12\uC774 \uC544\uB2D9\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `${args[0]} ${name} \uCD08\uACFC\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} ${args[0]}\uBCF4\uB2E4 \uC791\uAC70\uB098 \uAC19\uC544\uC57C \uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '\uD30C\uC77C \uD615\uC2DD\uC774 \uD5C8\uC6A9\uB418\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} ${args[0]} \uC720\uD615\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `${args[0]} ${name}\uBCF4\uB2E4 \uC791\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} ${args[0]} \uC774\uC0C1\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `${value}\" \uD5C8\uC6A9\uB418\uC9C0 \uC54A\uB294 ${name}\uC785\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} \uC22B\uC790\uC5EC\uC57C \uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} \uD544\uC218 \uAC12\uC785\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ${list(args)}\uB85C \uC2DC\uC791\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `\uC62C\uBC14\uB978 URL\uC744 \uC785\uB825\uD574\uC8FC\uC138\uC694`;\n        /* </i18n> */\n    },\n};\n\nvar ko = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$9,\n    validation: validation$9\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$8 = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Hapus',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Hapus semua',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Maaf, tidak semua bidang formulir terisi dengan benar',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Kirim',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Tidak ada file yang dipilih',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$8 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Tolong terima kolom ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} nilainya harus lebih dari waktu ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} harus berisi waktu di masa depan.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} hanya bisa diisi huruf alfabet.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} hanya bisa diisi huruf dan angka.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} hanya boleh berisi huruf dan spasi..`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} nilainya harus kurang dari waktu ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} harus berisi waktu yang sudah lampau.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Kolom ini tidak diisi dengan benar sehingga tidak bisa dikirim`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} harus bernilai diantara ${a} dan ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} nilainya tidak cocok.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} waktu tidak cocok, mohon gunakan format waktu ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Kolom ini tidak diisi dengan benar sehingga tidak bisa dikirim';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} harus diantara waktu ${date(args[0])} dan waktu ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Tolong tulis alamat email yang benar.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} nilainya tidak berakhiran dengan ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} adalah nilai yang tidak diizinkan.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} nilainya setidaknya berisi satu karakter.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} jumlah karakternya harus kurang dari atau sama dengan ${max} karakter.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} jumlah karakternya harus lebih dari atau sama dengan ${min} karakter.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} jumlah karakternya hanya bisa antara ${min} dan ${max} karakter.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} nilainya tidak diizinkan.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Tidak bisa memiliki lebih dari ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} harus lebih kecil atau sama dengan ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Format file tidak diizinkan';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} hanya bisa bertipe: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Tidak boleh kurang dari ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} setidaknya harus berisi ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D adalah nilai yang tidak diperbolehkan untuk ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} harus berupa angka.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} harus diisi.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} tidak dimulai dengan ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Mohon tuliskan url yang benar.`;\n        /* </i18n> */\n    },\n};\n\nvar id = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$8,\n    validation: validation$8\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$7 = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Rimuovi',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Rimuovi tutti',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Ci dispiace, non tutti i campi sono compilati correttamente.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Invia',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Nessun file selezionato',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$7 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Si prega di accettare ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `la data ${sentence(name)} deve essere successiva ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `la data ${sentence(name)} deve essere nel futuro.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} pu\u00F2 contenere solo caratteri alfanumerici.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} pu\u00F2 contenere solo lettere e numeri.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} pu\u00F2 contenere solo lettere e spazi.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `la data ${sentence(name)} deve essere antecedente ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} deve essere nel passato.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Questo campo \u00E8 stato configurato male e non pu\u00F2 essere inviato.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} deve essere tra ${a} e ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} non corrisponde.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} non \u00E8 una data valida, per favore usa il formato ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Questo campo \u00E8 stato configurato in modo errato e non pu\u00F2 essere inviato.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} deve essere tra ${date(args[0])} e ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Per favore inserire un indirizzo email valido.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} non termina con ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} non \u00E8 un valore consentito.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} deve contenere almeno un carattere.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} deve essere minore o uguale a ${max} caratteri.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} deve essere maggiore o uguale a ${min} caratteri.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} deve essere tra ${min} e ${max} caratteri.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} non \u00E8 un valore consentito.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Non pu\u00F2 avere pi\u00F9 di ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} deve essere minore o uguale a ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Formato file non consentito.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} deve essere di tipo: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Non pu\u00F2 avere meno di ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} deve essere almeno ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\"${value}\" non \u00E8 un ${name} consentito.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} deve essere un numero.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} \u00E8 richiesto.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} non inizia con ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Per favore utilizare un url valido.`;\n        /* </i18n> */\n    },\n};\n\nvar it = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$7,\n    validation: validation$7\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$6 = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Verwijder',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Verwijder alles',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Sorry, niet alle velden zijn correct ingevuld.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Versturen',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Geen bestand gekozen',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$6 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Accepteer de ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} moet na ${date(args[0])} zijn.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} moet in de toekomst liggen.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} mag alleen alfabetische tekens bevatten.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} mag alleen letters en cijfers bevatten.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} kunnen alleen letters en spaties bevatten.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} moet v\u00F3\u00F3r ${date(args[0])} vallen.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} moet in het verleden zijn.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Dit veld is onjuist geconfigureerd en kan niet worden verzonden.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} moet tussen ${a} en ${b} liggen.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} komt niet overeen.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} is geen geldige datum, gebruik de notatie ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Dit veld is onjuist geconfigureerd en kan niet worden verzonden';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} moet tussen ${date(args[0])} en ${date(args[1])} liggen`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Vul een geldig e-mailadres in.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} eindigt niet met ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} is geen toegestane waarde.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} moet minimaal \u00E9\u00E9n teken zijn.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} moet kleiner zijn dan of gelijk zijn aan ${max} tekens.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} moet groter zijn dan of gelijk zijn aan ${min} tekens.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} moet tussen de ${min} en ${max} tekens bevatten.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} is geen toegestane waarde.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Mag niet meer dan ${args[0]} ${name} hebben.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} moet kleiner zijn dan of gelijk zijn aan ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Geen bestandsformaten toegestaan.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} moet van het type: ${args[0]} zijn`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Mag niet minder dan ${args[0]} ${name} hebben.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} moet minimaal ${args[0]} zijn.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\"${value}\" is geen toegestane ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} moet een getal zijn.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} is verplicht.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} begint niet met ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Voeg een geldige url toe.`;\n        /* </i18n> */\n    },\n};\n\nvar nl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$6,\n    validation: validation$6\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$5 = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Usu\u0144',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Usu\u0144 wszystko',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Nie wszystkie pola zosta\u0142y wype\u0142nione poprawnie.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Wy\u015Blij',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Nie wybrano pliku',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$5 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Prosz\u0119 zaakceptowa\u0107 ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} musi by\u0107 po ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} musi by\u0107 w przysz\u0142o\u015Bci.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} mo\u017Ce tylko zawiera\u0107 znaki alfabetyczne.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} mo\u017Ce tylko zawiera\u0107 znaki alfanumeryczne.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} mog\u0105 zawiera\u0107 tylko litery i spacje.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} musi by\u0107 przed ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} musi by\u0107 w przesz\u0142o\u015Bci.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Pole zosta\u0142o wype\u0142nione niepoprawnie i nie mo\u017Ce zosta\u0107 wys\u0142ane.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} musi by\u0107 pomi\u0119dzy ${a} i ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} nie zgadza si\u0119.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} nie jest poprawn\u0105 dat\u0105, prosz\u0119 u\u017Cy\u0107 formatu ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'To pole zosta\u0142o wype\u0142nione niepoprawnie i nie mo\u017Ce zosta\u0107 wys\u0142ane';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} musi by\u0107 pomi\u0119dzy ${date(args[0])} i ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Prosz\u0119 wpisa\u0107 poprawny adres email.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} nie ko\u0144czy si\u0119 na ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} nie jest dozwolon\u0105 warto\u015Bci\u0105.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} musi posiada\u0107 minimum jeden znak.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} musi zawiera\u0107 ${max} lub mniej znak\u00F3w.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} musi zawiera\u0107 ${min} lub wi\u0119cej znak\u00F3w.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} musi mie\u0107 ${min}-${max} znak\u00F3w.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} nie jest dozwolon\u0105 warto\u015Bci\u0105.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Nie mo\u017Cna mie\u0107 wi\u0119cej ni\u017C ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} musi by\u0107 mniejsze lub r\u00F3wne ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Nie podano dozwolonych typ\u00F3w plik\u00F3w.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} musi by\u0107 typem: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Musisz poda\u0107 wi\u0119cej ni\u017C ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return ` Musisz poda\u0107 conajmniej ${args[0]} ${sentence(name)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D nie jest dozwolonym ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} musi by\u0107 numerem.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} jest wymagany.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} nie zaczyna si\u0119 od ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Prosz\u0119 poda\u0107 prawid\u0142owy adres url.`;\n        /* </i18n> */\n    },\n};\n\nvar pl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$5,\n    validation: validation$5\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$4 = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Remover',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Deletar tudo',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Desculpe, nem todos os campos foram preenchidos corretamente.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Enviar',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Nenhum arquivo',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$4 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Por favor aceite o ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} deve ser posterior a ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} deve ser no futuro.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} s\u00F3 pode conter caracteres do alfabeto.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} s\u00F3 pode ter letras e n\u00FAmeros.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} s\u00F3 podem conter letras e espa\u00E7os.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} deve ser anterior a ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} deve ser anterior a data atual.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `O campo foi configurado incorretamente e n\u00E3o pode ser enviado.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} deve estar entre ${args[0]} e ${args[1]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} n\u00E3o confere.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} n\u00E3o \u00E9 uma data v\u00E1lida, por favor use o formato ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'O campo foi configurado incorretamente e n\u00E3o pode ser enviado.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} deve ser entre ${date(args[0])} e ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Por favor informe um e-mail v\u00E1lido.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} n\u00E3o termina com ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} n\u00E3o \u00E9 um valor permitido.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} deve ter ao menos um caractere.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} n\u00E3o pode ter mais que ${max} caracteres.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} deve ter no m\u00EDnimo ${min} caracteres.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} deve ter entre ${min} e ${max} caracteres.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} n\u00E3o \u00E9 um valor permitido.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `N\u00E3o pode ter mais que ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} deve ser igual ou menor que ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Nenhum formato de arquivo permitido.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} deve ser do tipo: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `N\u00E3o pode ter menos que ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} deve ter pelo menos ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D n\u00E3o permite ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} deve ser um n\u00FAmero.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} \u00E9 obrigat\u00F3rio.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} n\u00E3o come\u00E7a com ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Por favor informe um url v\u00E1lido.`;\n        /* </i18n> */\n    },\n};\n\nvar pt = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$4,\n    validation: validation$4\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$3 = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: '\u0423\u0434\u0430\u043B\u0438\u0442\u044C',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: '\u0423\u0431\u0440\u0430\u0442\u044C \u0432\u0441\u0435',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: '\u0418\u0437\u0432\u0438\u043D\u0438\u0442\u0435, \u043D\u0435 \u0432\u0441\u0435 \u043F\u043E\u043B\u044F \u0437\u0430\u043F\u043E\u043B\u043D\u0435\u043D\u044B \u0432\u0435\u0440\u043D\u043E.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: '\u041E\u0442\u043F\u0440\u0430\u0432\u0438\u0442\u044C',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: '\u0424\u0430\u0439\u043B \u043D\u0435 \u0432\u044B\u0431\u0440\u0430\u043D',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$3 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u043F\u0440\u0438\u043C\u0438\u0442\u0435 ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `\u0414\u0430\u0442\u0430 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u043F\u043E\u0437\u0436\u0435 ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `\u0414\u0430\u0442\u0430 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u0432 \u0431\u0443\u0434\u0443\u0449\u0435\u043C.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u043C\u043E\u0436\u0435\u0442 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u0442\u043E\u043B\u044C\u043A\u043E \u0431\u0443\u043A\u0432\u044B.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u043C\u043E\u0436\u0435\u0442 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u0442\u043E\u043B\u044C\u043A\u043E \u0431\u0443\u043A\u0432\u044B \u0438 \u0446\u0438\u0444\u0440\u044B.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} \u043C\u043E\u0433\u0443\u0442 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u0442\u043E\u043B\u044C\u043A\u043E \u0431\u0443\u043A\u0432\u044B \u0438 \u043F\u0440\u043E\u0431\u0435\u043B\u044B.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `\u0414\u0430\u0442\u0430 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u0440\u0430\u043D\u044C\u0448\u0435 ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `\u0414\u0430\u0442\u0430 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u0432 \u043F\u0440\u043E\u0448\u043B\u043E\u043C.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `\u042D\u0442\u043E \u043F\u043E\u043B\u0435 \u0437\u0430\u043F\u043E\u043B\u043D\u0435\u043D\u043E \u043D\u0435\u0432\u0435\u0440\u043D\u043E \u0438 \u043D\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u043E.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043C\u0435\u0436\u0434\u0443 ${a} \u0438 ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u043D\u0435 \u0441\u043E\u0432\u043F\u0430\u0434\u0430\u0435\u0442.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0438\u043C\u0435\u0435\u0442 \u043D\u0435\u0432\u0435\u0440\u043D\u0443\u044E \u0434\u0430\u0442\u0443. \u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0439\u0442\u0435 \u0444\u043E\u0440\u043C\u0430\u0442 ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return '\u042D\u0442\u043E \u043F\u043E\u043B\u0435 \u0437\u0430\u043F\u043E\u043B\u043D\u0435\u043D\u043E \u043D\u0435\u0432\u0435\u0440\u043D\u043E \u0438 \u043D\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u043E.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `\u0414\u0430\u0442\u0430 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u043C\u0435\u0436\u0434\u0443 ${date(args[0])} \u0438 ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: '\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0432\u0432\u0435\u0434\u0438\u0442\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 \u044D\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u044B\u0439 \u0430\u0434\u0440\u0435\u0441.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u043D\u0435 \u0434\u043E\u043B\u0436\u043D\u043E \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0438\u043C\u0435\u0435\u0442 \u043D\u0435\u043F\u043E\u0434\u0443\u0441\u0442\u0438\u043C\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u043E \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u043C\u0438\u043D\u0438\u043C\u0443\u043C \u043E\u0434\u0438\u043D \u0441\u0438\u043C\u0432\u043E\u043B.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `\u0414\u043B\u0438\u043D\u0430 \u043F\u043E\u043B\u044F ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u043C\u0435\u043D\u044C\u0448\u0435 \u0438\u043B\u0438 \u0440\u0430\u0432\u043D\u0430 ${max} \u0441\u0438\u043C\u0432\u043E\u043B\u0430\u043C.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `\u0414\u043B\u0438\u043D\u0430 \u043F\u043E\u043B\u044F ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u0431\u043E\u043B\u044C\u0448\u0435 \u0438\u043B\u0438 \u0440\u0430\u0432\u043D\u0430 ${min} \u0441\u0438\u043C\u0432\u043E\u043B\u0430\u043C.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `\u0414\u043B\u0438\u043D\u0430 \u043F\u043E\u043B\u044F ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u043C\u0435\u0436\u0434\u0443 ${min} \u0438 ${max} \u0441\u0438\u043C\u0432\u043E\u043B\u0430\u043C\u0438.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0438\u043C\u0435\u0435\u0442 \u043D\u0435\u0434\u043E\u043F\u0443\u0441\u0442\u0438\u043C\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `\u041D\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u0432\u044B\u0431\u0440\u0430\u043D\u043E \u0431\u043E\u043B\u044C\u0448\u0435, \u0447\u0435\u043C ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043C\u0435\u043D\u044C\u0448\u0435 \u0438\u043B\u0438 \u0440\u0430\u0432\u043D\u043E ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '\u041D\u0435 \u0443\u043A\u0430\u0437\u0430\u043D\u044B \u043F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0430\u0432\u0435\u043C\u044B\u0435 \u0444\u043E\u0440\u043C\u0430\u0442\u044B \u0444\u0430\u0439\u043B\u0430.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `\u0424\u043E\u0440\u043C\u0430\u0442 \u0444\u0430\u0439\u043B\u0430 \u0432 \u043F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u0435\u043D \u0431\u044B\u0442\u044C: ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `\u041D\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u0432\u044B\u0431\u0440\u0430\u043D\u043E \u043C\u0435\u043D\u044C\u0448\u0435, \u0447\u0435\u043C ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043D\u0435 \u043C\u0435\u043D\u0435\u0435, \u0447\u0435\u043C ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D \u043D\u0435 \u043F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442\u0441\u044F \u0432 \u043F\u043E\u043B\u0435 ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u0447\u0438\u0441\u043B\u043E\u043C.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u043E\u0431\u044F\u0437\u0430\u0442\u0435\u043B\u044C\u043D\u043E \u0434\u043B\u044F \u0437\u0430\u043F\u043E\u043B\u043D\u0435\u043D\u0438\u044F.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u043E \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0432\u0432\u0435\u0434\u0438\u0442\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 URL \u0430\u0434\u0440\u0435\u0441.`;\n        /* </i18n> */\n    },\n};\n\nvar ru = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$3,\n    validation: validation$3\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$2 = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Kald\u0131r',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Hepsini kald\u0131r',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Maalesef, t\u00FCm alanlar do\u011Fru doldurulmad\u0131.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'G\u00F6nder',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Dosya yok',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$2 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `L\u00FCtfen ${name}'yi kabul edin.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} ${date(args[0])}'den sonra olmal\u0131d\u0131r.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} gelecekte bir zaman olmal\u0131d\u0131r.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} sadece alfabetik karakterler i\u00E7erebilir.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} sadece alfabetik karakterler ve say\u0131 i\u00E7erebilir.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} yaln\u0131zca harf ve bo\u015Fluk i\u00E7erebilir.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} ${date(args[0])} tarihinden \u00F6nce olmal\u0131.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} ge\u00E7mi\u015Fte olmal\u0131.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Alan yanl\u0131\u015F yap\u0131land\u0131r\u0131lm\u0131\u015F ve g\u00F6nderilemez.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} ${args[0]} ve ${args[1]} aral\u0131\u011F\u0131nda olmal\u0131.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} e\u015Fle\u015Fmiyor.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} ge\u00E7erli bir tarih de\u011Fil, l\u00FCtfen ${args[0]} bi\u00E7imini kullan\u0131n.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Alan yanl\u0131\u015F yap\u0131land\u0131r\u0131lm\u0131\u015F ve g\u00F6nderilemez.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)}, ${date(args[0])} ve ${date(args[1])} aral\u0131\u011F\u0131nda olmal\u0131.`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'L\u00FCtfen ge\u00E7erli bir e-mail adresi girin.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ${list(args)} ile bitmiyor.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} izin verilen bir de\u011Fer de\u011Fil.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} en az\u0131ndan bir karakter uzunlu\u011Funda olmal\u0131.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} ${max}'e e\u015Fit veya daha k\u00FC\u00E7\u00FCk olmal\u0131.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} ${min}'e e\u015Fit veya daha b\u00FCy\u00FCk olmal\u0131.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)}, ${min} ve ${max} karakter uzunlu\u011Fu aral\u0131\u011F\u0131nda olmal\u0131.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} izin verilen bir de\u011Fer de\u011Fil.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `${name}'in uzunlu\u011Fu ${args[0]}'dan daha uzun olamaz.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} en az\u0131ndan ${args[0]} uzunlu\u011Funda veya ona e\u015Fit olmal\u0131.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Hi\u00E7bir dosya t\u00FCr\u00FCne izin verilmez.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} \u015Fu tiplerden biri olmal\u0131: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `${name}'in uzunlu\u011Fu ${args[0]}'dan daha k\u0131sa olamaz.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} en az\u0131ndan ${args[0]} uzunlu\u011Funda olmal\u0131.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D ${name} olamaz.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} say\u0131 olmal\u0131.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} gerekli.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ${list(args)} ile ba\u015Flam\u0131yor.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `L\u00FCtfen ge\u00E7erli bir url dahil edin.`;\n        /* </i18n> */\n    },\n};\n\nvar tr = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$2,\n    validation: validation$2\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$1 = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Xo\u00E1',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Xo\u00E1 t\u1EA5t c\u1EA3',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Xin l\u1ED7i, kh\u00F4ng ph\u1EA3i t\u1EA5t c\u1EA3 c\u00E1c tr\u01B0\u1EDDng \u0111\u1EC1u \u0111\u01B0\u1EE3c nh\u1EADp \u0111\u00FAng.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'G\u1EEDi',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Ch\u01B0a ch\u1ECDn file',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$1 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `H\u00E3y \u0111\u1ED3ng \u00FD v\u1EDBi ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} ph\u1EA3i sau ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} ph\u1EA3i trong t\u01B0\u01A1ng lai.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} c\u00F3 th\u1EC3 ch\u1EC9 bao g\u1ED3m c\u00E1c ch\u1EEF c\u00E1i alphabet.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} c\u00F3 th\u1EC3 ch\u1EC9 bao g\u1ED3m c\u00E1c ch\u1EEF c\u00E1i v\u00E0 ch\u1EEF s\u1ED1.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} ch\u1EC9 c\u00F3 th\u1EC3 ch\u1EE9a c\u00E1c ch\u1EEF c\u00E1i v\u00E0 kho\u1EA3ng tr\u1EAFng.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} ph\u1EA3i tr\u01B0\u1EDBc ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} ph\u1EA3i trong qu\u00E1 kh\u1EE9.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Tr\u01B0\u1EDDng n\u00E0y \u0111\u00E3 \u0111\u01B0\u1EE3c thi\u1EBFt l\u1EADp sai v\u00E0 kh\u00F4ng th\u1EC3 g\u1EEDi.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} ph\u1EA3i \u1EDF gi\u1EEFa ${a} v\u00E0 ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} kh\u00F4ng kh\u1EDBp.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} kh\u00F4ng ph\u1EA3i ng\u00E0y h\u1EE3p l\u1EC7, h\u00E3y s\u1EED d\u1EE5ng \u0111\u1ECBnh d\u1EA1ng ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Tr\u01B0\u1EDDng n\u00E0y \u0111\u00E3 \u0111\u01B0\u1EE3c thi\u1EBFt l\u1EADp sai v\u00E0 kh\u00F4ng th\u1EC3 g\u1EEDi.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} ph\u1EA3i \u1EDF gi\u1EEFa kho\u1EA3ng t\u1EEB ${date(args[0])} \u0111\u1EBFn ${date(args[1])}.`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'H\u00E3y nh\u1EADp m\u1ED9t \u0111\u1ECBa ch\u1EC9 email h\u1EE3p l\u1EC7.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} kh\u00F4ng k\u1EBFt th\u00FAc v\u1EDBi ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} kh\u00F4ng ph\u1EA3i m\u1ED9t gi\u00E1 tr\u1ECB \u0111\u01B0\u1EE3c cho ph\u00E9p.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} ph\u1EA3i c\u00F3 \u0111\u1ED9 d\u00E0i t\u1ED1i thi\u1EC3u m\u1ED9t k\u00FD t\u1EF1.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} ph\u1EA3i c\u00F3 \u0111\u1ED9 d\u00E0i t\u1ED1i \u0111a ${max} k\u00FD t\u1EF1.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} ph\u1EA3i c\u00F3 \u0111\u1ED9 d\u00E0i t\u1ED1i thi\u1EC3u ${min} k\u00FD t\u1EF1.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} ph\u1EA3i c\u00F3 \u0111\u1ED9 d\u00E0i t\u1ED1i \u0111a trong kho\u1EA3ng t\u1EEB ${min} \u0111\u1EBFn ${max} k\u00FD t\u1EF1.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} kh\u00F4ng ph\u1EA3i m\u1ED9t gi\u00E1 tr\u1ECB \u0111\u01B0\u1EE3c cho ph\u00E9p.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `${name} kh\u00F4ng th\u1EC3 l\u1EDBn h\u01A1n ${args[0]}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} ph\u1EA3i t\u1ED1i \u0111a b\u1EB1ng ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '\u0110\u1ECBnh d\u1EA1ng t\u1EC7p tin n\u00E0y kh\u00F4ng \u0111\u01B0\u1EE3c ph\u00E9p.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} ph\u1EA3i l\u00E0 m\u1ED9t trong c\u00E1c d\u1EA1ng: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `${name} kh\u00F4ng th\u1EC3 nh\u1ECF h\u01A1n ${args[0]}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} ph\u1EA3i t\u1ED1i thi\u1EC3u b\u1EB1ng ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\"${value}\" kh\u00F4ng ph\u1EA3i gi\u00E1 tr\u1ECB ${name} \u0111\u01B0\u1EE3c ph\u00E9p.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} ph\u1EA3i l\u00E0 m\u1ED9t s\u1ED1.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} l\u00E0 b\u1EAFt bu\u1ED9c.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} kh\u00F4ng b\u1EAFt \u0111\u1EA7u v\u1EDBi ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `H\u00E3y nh\u1EADp m\u1ED9t URL h\u1EE3p l\u1EC7.`;\n        /* </i18n> */\n    },\n};\n\nvar vi = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$1,\n    validation: validation$1\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: '\u79FB\u9664',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: '\u5BF9\u4E0D\u8D77\uFF0C\u6709\u4E9B\u5B57\u6BB5\u672A\u88AB\u6B63\u786E\u586B\u5199',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: '\u63D0\u4EA4',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `\u8BF7\u63A5\u53D7${name}`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)}\u5FC5\u987B\u665A\u4E8E${date(args[0])}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)}\u5FC5\u987B\u662F\u672A\u6765\u7684\u65E5\u671F`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)}\u4EC5\u80FD\u5305\u542B\u5B57\u6BCD\u5B57\u7B26`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)}\u4EC5\u80FD\u5305\u542B\u5B57\u6BCD\u548C\u6570\u5B57`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)}\u53EA\u80FD\u5305\u542B\u5B57\u6BCD\u548C\u7A7A\u683C`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)}\u5FC5\u987B\u65E9\u4E8E${date(args[0])}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)}\u5FC5\u987B\u662F\u8FC7\u53BB\u7684\u65E5\u671F`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `\u8BE5\u5B57\u6BB5\u672A\u88AB\u6B63\u786E\u8BBE\u7F6E\u800C\u65E0\u6CD5\u88AB\u63D0\u4EA4`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)}\u5FC5\u987B\u5728${args[0]}\u548C${args[1]}\u4E4B\u95F4`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)}\u4E0D\u5339\u914D`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)}\u4E0D\u662F\u4E00\u4E2A\u5408\u6CD5\u65E5\u671F\uFF0C\u8BF7\u4F7F\u7528\u6B64\u683C\u5F0F${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return '\u8BE5\u5B57\u6BB5\u672A\u88AB\u6B63\u786E\u8BBE\u7F6E\u800C\u65E0\u6CD5\u88AB\u63D0\u4EA4';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)}\u5FC5\u987B\u5728${date(args[0])}\u548C${date(args[1])}\u4E4B\u95F4`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: '\u8BF7\u8F93\u5165\u4E00\u4E2A\u5408\u6CD5\u7684\u7535\u5B50\u90AE\u4EF6\u5730\u5740',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)}\u5E76\u672A\u4EE5${list(args)}\u7ED3\u5C3E`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)}\u4E0D\u662F\u4E00\u4E2A\u5141\u8BB8\u503C`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)}\u81F3\u5C11\u8981\u6709\u4E00\u4E2A\u5B57\u7B26`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)}\u5FC5\u987B\u5C11\u4E8E\u6216\u7B49\u4E8E${max}\u4E2A\u5B57\u7B26`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)}\u5FC5\u987B\u591A\u4E8E\u6216\u7B49\u4E8E${min}\u4E2A\u5B57\u7B26`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)}\u5FC5\u987B\u6709${min}\u81F3${max}\u4E2A\u5B57\u7B26`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)}\u4E0D\u662F\u4E00\u4E2A\u5141\u8BB8\u503C`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `${name}\u4E0D\u80FD\u8D85\u8FC7${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)}\u5FC5\u987B\u5C0F\u4E8E\u6216\u7B49\u4E8E${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '\u65E0\u5141\u8BB8\u7684\u6587\u4EF6\u683C\u5F0F';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)}\u5FC5\u987B\u4E3A\u6B64\u7C7B\u578B\uFF1A${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `${name}\u4E0D\u80FD\u5C11\u4E8E${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)}\u4E0D\u80FD\u5C0F\u4E8E${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D\u4E0D\u662F\u4E00\u4E2A\u88AB\u5141\u8BB8\u7684${name}`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)}\u5FC5\u987B\u662F\u4E00\u4E2A\u6570\u5B57`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)}\u5FC5\u987B\u586B\u5199`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)}\u6CA1\u6709\u4EE5${list(args)}\u5F00\u5934`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `\u8BF7\u5305\u542B\u4E00\u4E2A\u5408\u6CD5\u7684url`;\n        /* </i18n> */\n    },\n};\n\nvar zh = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui,\n    validation: validation\n});\n\n/**\n * Create a new internationalization plugin for FormKit.\n * @param locales - Creates the i18n plugin.\n * @public\n */\nfunction createI18nPlugin(registry) {\n    return function i18nPlugin(node) {\n        let localeKey = parseLocale(node.config.locale, registry);\n        let locale = localeKey ? registry[localeKey] : {};\n        /* If the locale prop changes, update the active locale */\n        node.on('prop:locale', ({ payload: lang }) => {\n            localeKey = parseLocale(lang, registry);\n            locale = localeKey ? registry[localeKey] : {};\n            // Run through all the messages in the store and update with new locale\n            node.store.touch();\n        });\n        /**\n         * Hook into the core text or t() hook to perform localization on the\n         * output of core functionality.\n         */\n        node.hook.text((fragment, next) => {\n            var _a, _b;\n            const key = ((_a = fragment.meta) === null || _a === void 0 ? void 0 : _a.messageKey) || fragment.key;\n            if (has(locale, fragment.type) && has(locale[fragment.type], key)) {\n                const t = locale[fragment.type][key];\n                if (typeof t === 'function') {\n                    fragment.value = Array.isArray((_b = fragment.meta) === null || _b === void 0 ? void 0 : _b.i18nArgs)\n                        ? t(...fragment.meta.i18nArgs) // eslint-disable-line @typescript-eslint/no-non-null-assertion\n                        : t(fragment);\n                }\n                else {\n                    fragment.value = t;\n                }\n            }\n            return next(fragment);\n        });\n    };\n}\n/**\n * @param locale - An ISO 639-1 and (optionally) ISO 639-2 language tag. For\n * example these are valid locale keys:\n * zh\n * zh-CN\n * zh-HK\n * en\n * en-GB\n * @param availableLocales - An array of locales that may be valid.\n */\nfunction parseLocale(locale, availableLocales) {\n    if (has(availableLocales, locale)) {\n        return locale;\n    }\n    const [lang] = locale.split('-');\n    if (has(availableLocales, lang)) {\n        return lang;\n    }\n    for (const locale in availableLocales) {\n        return locale;\n    }\n    return false;\n}\n\n/**\n * Export all the available locales at once.\n * @public\n */\nconst locales = {\n    ar,\n    cs,\n    da,\n    de,\n    en,\n    es,\n    fa,\n    fi,\n    fr,\n    fy,\n    he,\n    hr,\n    id,\n    it,\n    ko,\n    nl,\n    pl,\n    pt,\n    ru,\n    tr,\n    vi,\n    zh,\n};\n\nexport { ar, createI18nPlugin, cs, da, date, de, en, es, fa, fi, fr, fy, he, hr, id, it, ko, list, locales, nl, order, pl, pt, ru, sentence, tr, vi, zh };\n", "import { errorHandler, warningHandler } from '@formkit/core';\n\nlet registered = false;\n/**\n * Catalog of the error message codes in FormKit.\n * @public\n */\nconst errors = {\n    /**\n     * FormKit errors:\n     */\n    100: ({ data: node }) => `Only groups, lists, and forms can have children (${node.name}).`,\n    101: ({ data: node }) => `You cannot directly modify the store (${node.name}). See: https://formkit.com/advanced/core#message-store`,\n    102: ({ data: [node, property], }) => `You cannot directly assign node.${property} (${node.name})`,\n    103: ({ data: [operator] }) => `Schema expressions cannot start with an operator (${operator})`,\n    104: ({ data: [operator, expression] }) => `Schema expressions cannot end with an operator (${operator} in \"${expression}\")`,\n    105: ({ data: expression }) => `Invalid schema expression: ${expression}`,\n    106: ({ data: name }) => `Cannot submit because (${name}) is not in a form.`,\n    107: ({ data: [node, value] }) => `Cannot set ${node.name} to non object value: ${value}`,\n    108: ({ data: [node, value] }) => `Cannot set ${node.name} to non array value: ${value}`,\n    /**\n     * FormKit vue errors:\n     */\n    600: ({ data: node }) => `Unknown input type${typeof node.props.type === 'string' ? ' \"' + node.props.type + '\"' : ''} (\"${node.name}\")`,\n    601: ({ data: node }) => `Input definition${typeof node.props.type === 'string' ? ' \"' + node.props.type + '\"' : ''} is missing a schema or component property (${node.name}).`,\n};\n/**\n * Catalog of the warning message codes in FormKit.\n * @public\n */\nconst warnings = {\n    /**\n     * Core warnings:\n     */\n    150: ({ data: fn }) => `Schema function \"${fn}()\" is not a valid function.`,\n    151: ({ data: id }) => `No form element with id: ${id}`,\n    152: ({ data: id }) => `No input element with id: ${id}`,\n    /**\n     * Input specific warnings:\n     */\n    350: ({ data: node }) => `Invalid options prop for radio input (${node.name}). See https://formkit.com/inputs/radio`,\n    /**\n     * Vue warnings:\n     */\n    650: 'Schema \"$get()\" must use the id of an input to access.',\n    651: ({ data: id }) => `Cannot setErrors() on \"${id}\" because no such id exists.`,\n};\n/**\n * Decodes an error that is being emitted and console logs it.\n * @param error - The error currently being handled\n * @param next - Call additional handlers\n * @returns\n */\nconst decodeErrors = (error, next) => {\n    if (error.code in errors) {\n        const err = errors[error.code];\n        error.message = typeof err === 'function' ? err(error) : err;\n    }\n    return next(error);\n};\nif (!registered)\n    errorHandler(decodeErrors);\n/**\n * Decodes an error that is being emitted and console logs it.\n * @param error - The error currently being handled\n * @param next - Call additional handlers\n * @returns\n */\nconst decodeWarnings = (warning, next) => {\n    if (warning.code in warnings) {\n        const warn = warnings[warning.code];\n        warning.message = typeof warn === 'function' ? warn(warning) : warn;\n    }\n    return next(warning);\n};\nif (!registered)\n    warningHandler(decodeWarnings);\nregistered = true;\n\nexport { errors, warnings };\n", "import { warn, getNode, watchRegistry, isNode, sugar, isDOM, isComponent as isComponent$1, isConditional, compile, error, createConfig, setErrors, submitForm, reset, createNode, createMessage, createClasses, generateClassList } from '@formkit/core';\nexport { errorHandler, reset, resetCount, setErrors, submitForm } from '@formkit/core';\nimport { defineComponent, getCurrentInstance, watch, watchEffect, reactive, ref, createTextVNode, resolveComponent, h, inject, provide, onUnmounted, markRaw, computed } from 'vue';\nimport { has, isPojo, cloneAny, extend, camel, kebab, nodeProps, only, except, slugify, empty, eq } from '@formkit/utils';\nimport { useSchema, createLibraryPlugin, inputs } from '@formkit/inputs';\nimport * as defaultRules from '@formkit/rules';\nimport { createValidationPlugin } from '@formkit/validation';\nimport { createI18nPlugin, en } from '@formkit/i18n';\nimport { createObserver } from '@formkit/observer';\nimport '@formkit/dev';\n\n/**\n * A registry of memoized schemas (in JSON) to their respective render function\n * and provider registry.\n */\nconst memo = {};\n/**\n * This symbol represents the current component instance during render. It is\n * critical for linking the current instance to the data required for render.\n */\nlet instanceKey;\n/**\n * A registry of scoped data produced during runtime that is keyed by the\n * instance symbol. For example data from: for-loop instances and slot data.\n */\nconst instanceScopes = new Map();\n/**\n * Indicates the a section of the schema is raw.\n */\nconst raw = '__raw__';\n/**\n * Is a class prop.\n */\nconst isClassProp = /[a-zA-Z0-9\\-][cC]lass$/;\n/**\n * Returns a reference as a placeholder to a specific location on an object.\n * @param data - A reactive data object\n * @param token - A dot-syntax string representing the object path\n * @returns\n */\nfunction getRef(token, data) {\n    const value = ref(null);\n    const nodeRef = ref(undefined);\n    if (token === 'get') {\n        value.value = get.bind(null, nodeRef);\n        return value;\n    }\n    const path = token.split('.');\n    watchEffect(() => (value.value = getValue(data, path)));\n    return value;\n}\n/**\n * Returns a value inside a set of data objects.\n * @param sets - An array of objects to search through\n * @param path - A array of string paths easily produced by split()\n * @returns\n */\nfunction getValue(set, path) {\n    if (Array.isArray(set)) {\n        for (const subset of set) {\n            const value = subset !== false && getValue(subset, path);\n            if (value !== undefined)\n                return value;\n        }\n        return undefined;\n    }\n    let foundValue = undefined;\n    path.reduce((obj, segment, i, arr) => {\n        if (typeof obj !== 'object') {\n            foundValue = undefined;\n            return arr.splice(1); // Forces an exit\n        }\n        const currentValue = obj[segment];\n        if (i === path.length - 1 && currentValue !== undefined) {\n            foundValue = currentValue;\n        }\n        return obj[segment];\n    }, set);\n    return foundValue;\n}\n/**\n * Get the node from the global registry\n * @param id - A dot-syntax string where the node is located.\n */\nfunction get(nodeRef, id) {\n    if (typeof id !== 'string')\n        return warn(650);\n    if (nodeRef.value === undefined) {\n        nodeRef.value = null;\n        const root = getNode(id);\n        if (root)\n            nodeRef.value = root.context;\n        watchRegistry(id, ({ payload: node }) => {\n            nodeRef.value = isNode(node) ? node.context : node;\n        });\n    }\n    return nodeRef.value;\n}\n/**\n *\n * @param library - A library of concrete components to use\n * @param schema -\n * @returns\n */\nfunction parseSchema(library, schema) {\n    /**\n     * Given an if/then/else schema node, pre-compile the node and return the\n     * artifacts for the render function.\n     * @param data - The schema context object\n     * @param library - The available components\n     * @param node - The node to parse\n     */\n    function parseCondition(library, node) {\n        const condition = provider(compile(node.if), { if: true });\n        const children = createElements(library, node.then);\n        const alternate = node.else ? createElements(library, node.else) : null;\n        return [condition, children, alternate];\n    }\n    /**\n     * Parses a conditional if/then/else attribute statement.\n     * @param data - The data object\n     * @param attr - The attribute\n     * @param _default - The default value\n     * @returns\n     */\n    function parseConditionAttr(attr, _default) {\n        var _a, _b;\n        const condition = provider(compile(attr.if));\n        let b = () => _default;\n        let a = () => _default;\n        if (typeof attr.then === 'object') {\n            a = parseAttrs(attr.then, undefined);\n        }\n        else if (typeof attr.then === 'string' && ((_a = attr.then) === null || _a === void 0 ? void 0 : _a.startsWith('$'))) {\n            a = provider(compile(attr.then));\n        }\n        else {\n            a = () => attr.then;\n        }\n        if (has(attr, 'else')) {\n            if (typeof attr.else === 'object') {\n                b = parseAttrs(attr.else);\n            }\n            else if (typeof attr.else === 'string' && ((_b = attr.else) === null || _b === void 0 ? void 0 : _b.startsWith('$'))) {\n                b = provider(compile(attr.else));\n            }\n            else {\n                b = () => attr.else;\n            }\n        }\n        return () => (condition() ? a() : b());\n    }\n    /**\n     * Parse attributes for dynamic content.\n     * @param attrs - Object of attributes\n     * @returns\n     */\n    function parseAttrs(unparsedAttrs, bindExp, _default = {}) {\n        const explicitAttrs = new Set(Object.keys(unparsedAttrs || {}));\n        const boundAttrs = bindExp ? provider(compile(bindExp)) : () => ({});\n        const staticAttrs = {};\n        const setters = [\n            (attrs) => {\n                const bound = boundAttrs();\n                for (const attr in bound) {\n                    if (!explicitAttrs.has(attr)) {\n                        attrs[attr] = bound[attr];\n                    }\n                }\n            },\n        ];\n        if (unparsedAttrs) {\n            if (isConditional(unparsedAttrs)) {\n                // This is a root conditional object that must produce an object of\n                // attributes.\n                const condition = parseConditionAttr(unparsedAttrs, _default);\n                return condition;\n            }\n            // Some attributes are explicitly bound, we need to parse those ones\n            // using the compiler and create a dynamic \"setter\".\n            for (let attr in unparsedAttrs) {\n                const value = unparsedAttrs[attr];\n                let getValue;\n                const isStr = typeof value === 'string';\n                if (attr.startsWith(raw)) {\n                    // attributes prefixed with __raw__ should not be parsed\n                    attr = attr.substring(7);\n                    getValue = () => value;\n                }\n                else if (isStr &&\n                    value.startsWith('$') &&\n                    value.length > 1 &&\n                    !(value.startsWith('$reset') && isClassProp.test(attr))) {\n                    // Most attribute values starting with $ should be compiled\n                    // -class attributes starting with `$reset` should not be compiled\n                    getValue = provider(compile(value));\n                }\n                else if (typeof value === 'object' && isConditional(value)) {\n                    // Conditional attrs require further processing\n                    getValue = parseConditionAttr(value, undefined);\n                }\n                else if (typeof value === 'object' && isPojo(value)) {\n                    // Sub-parse pojos\n                    getValue = parseAttrs(value);\n                }\n                else {\n                    // In all other cases, the value is static\n                    getValue = () => value;\n                    staticAttrs[attr] = value;\n                }\n                setters.push((attrs) => {\n                    attrs[attr] = getValue();\n                });\n            }\n        }\n        return () => {\n            const attrs = {};\n            setters.forEach((setter) => setter(attrs));\n            return attrs;\n        };\n    }\n    /**\n     * Given a single schema node, parse it and extract the value.\n     * @param data - A state object provided to each node\n     * @param node - The schema node being parsed\n     * @returns\n     */\n    function parseNode(library, _node) {\n        let element = null;\n        let attrs = () => null;\n        let condition = false;\n        let children = null;\n        let alternate = null;\n        let iterator = null;\n        let resolve = false;\n        const node = sugar(_node);\n        if (isDOM(node)) {\n            // This is an actual HTML DOM element\n            element = node.$el;\n            attrs =\n                node.$el !== 'text' ? parseAttrs(node.attrs, node.bind) : () => null;\n        }\n        else if (isComponent$1(node)) {\n            // This is a Vue Component\n            if (typeof node.$cmp === 'string') {\n                if (has(library, node.$cmp)) {\n                    element = library[node.$cmp];\n                }\n                else {\n                    element = node.$cmp;\n                    resolve = true;\n                }\n            }\n            else {\n                // in this case it must be an actual component\n                element = node.$cmp;\n            }\n            attrs = parseAttrs(node.props, node.bind);\n        }\n        else if (isConditional(node)) {\n            [condition, children, alternate] = parseCondition(library, node);\n        }\n        // This is the same as a \"v-if\" statement \u2014 not an if/else statement\n        if (!isConditional(node) && 'if' in node) {\n            condition = provider(compile(node.if));\n        }\n        else if (!isConditional(node) && element === null) {\n            // In this odd case our element is actually a partial and\n            // we only want to render the children.\n            condition = () => true;\n        }\n        // Compile children down to a function\n        if ('children' in node && node.children) {\n            if (typeof node.children === 'string') {\n                // We are dealing with a raw string value\n                if (node.children.startsWith('$slots.')) {\n                    // this is a lone text node, turn it into a slot\n                    element = element === 'text' ? 'slot' : element;\n                    children = provider(compile(node.children));\n                }\n                else if (node.children.startsWith('$') && node.children.length > 1) {\n                    const value = provider(compile(node.children));\n                    children = () => String(value());\n                }\n                else {\n                    children = () => String(node.children);\n                }\n            }\n            else if (Array.isArray(node.children)) {\n                // We are dealing with node sub-children\n                children = createElements(library, node.children);\n            }\n            else {\n                // This is a conditional if/else clause\n                const [childCondition, c, a] = parseCondition(library, node.children);\n                children = (iterationData) => childCondition && childCondition()\n                    ? c && c(iterationData)\n                    : a && a(iterationData);\n            }\n        }\n        if (isComponent$1(node)) {\n            if (children) {\n                // Children of components need to be provided as an object of slots\n                // so we provide an object with the default slot provided as children.\n                // We also create a new scope for this default slot, and then on each\n                // render pass the scoped slot props to the scope.\n                const produceChildren = children;\n                children = (iterationData) => {\n                    return {\n                        default(slotData, key) {\n                            var _a, _b, _c, _d;\n                            // We need to switch the current instance key back to the one that\n                            // originally called this component's render function.\n                            const currentKey = instanceKey;\n                            if (key)\n                                instanceKey = key;\n                            if (slotData)\n                                (_a = instanceScopes.get(instanceKey)) === null || _a === void 0 ? void 0 : _a.unshift(slotData);\n                            if (iterationData)\n                                (_b = instanceScopes.get(instanceKey)) === null || _b === void 0 ? void 0 : _b.unshift(iterationData);\n                            const c = produceChildren(iterationData);\n                            // Ensure our instance key never changed during runtime\n                            if (slotData)\n                                (_c = instanceScopes.get(instanceKey)) === null || _c === void 0 ? void 0 : _c.shift();\n                            if (iterationData)\n                                (_d = instanceScopes.get(instanceKey)) === null || _d === void 0 ? void 0 : _d.shift();\n                            instanceKey = currentKey;\n                            return c;\n                        },\n                    };\n                };\n                children.slot = true;\n            }\n            else {\n                // If we dont have any children, we still need to provide an object\n                // instead of an empty array (which raises a warning in vue)\n                children = () => ({});\n            }\n        }\n        // Compile the for loop down\n        if ('for' in node && node.for) {\n            const values = node.for.length === 3 ? node.for[2] : node.for[1];\n            const getValues = typeof values === 'string' && values.startsWith('$')\n                ? provider(compile(values))\n                : () => values;\n            iterator = [\n                getValues,\n                node.for[0],\n                node.for.length === 3 ? String(node.for[1]) : null,\n            ];\n        }\n        return [condition, element, attrs, children, alternate, iterator, resolve];\n    }\n    /**\n     * Given a particular function that produces children, ensure that the second\n     * argument of all these slots is the original instance key being used to\n     * render the slots.\n     * @param children - The children() function that will produce slots\n     */\n    function createSlots(children, iterationData) {\n        const slots = children(iterationData);\n        const currentKey = instanceKey;\n        return Object.keys(slots).reduce((allSlots, slotName) => {\n            const slotFn = slots && slots[slotName];\n            allSlots[slotName] = (data) => {\n                return (slotFn && slotFn(data, currentKey)) || null;\n            };\n            return allSlots;\n        }, {});\n    }\n    /**\n     * Creates an element\n     * @param data - The context data available to the node\n     * @param node - The schema node to render\n     * @returns\n     */\n    function createElement(library, node) {\n        // Parses the schema node into pertinent parts\n        const [condition, element, attrs, children, alternate, iterator, resolve] = parseNode(library, node);\n        // This is a sub-render function (called within a render function). It must\n        // only use pre-compiled features, and be organized in the most efficient\n        // manner possible.\n        let createNodes = ((iterationData) => {\n            if (condition && element === null && children) {\n                // Handle conditional if/then statements\n                return condition()\n                    ? children(iterationData)\n                    : alternate && alternate(iterationData);\n            }\n            if (element && (!condition || condition())) {\n                // handle text nodes\n                if (element === 'text' && children) {\n                    return createTextVNode(String(children()));\n                }\n                // Handle lone slots\n                if (element === 'slot' && children)\n                    return children(iterationData);\n                // Handle resolving components\n                const el = resolve ? resolveComponent(element) : element;\n                // If we are rendering slots as children, ensure their instanceKey is properly added\n                const slots = (children === null || children === void 0 ? void 0 : children.slot)\n                    ? createSlots(children, iterationData)\n                    : null;\n                // Handle dom elements and components\n                return h(el, attrs(), (slots || (children ? children(iterationData) : [])));\n            }\n            return typeof alternate === 'function'\n                ? alternate(iterationData)\n                : alternate;\n        });\n        if (iterator) {\n            const repeatedNode = createNodes;\n            const [getValues, valueName, keyName] = iterator;\n            createNodes = (() => {\n                const _v = getValues();\n                const values = !isNaN(_v)\n                    ? Array(Number(_v))\n                        .fill(0)\n                        .map((_, i) => i)\n                    : _v;\n                const fragment = [];\n                if (typeof values !== 'object')\n                    return null;\n                const instanceScope = instanceScopes.get(instanceKey) || [];\n                for (const key in values) {\n                    const iterationData = Object.defineProperty({\n                        ...instanceScope.reduce((previousIterationData, scopedData) => {\n                            if (previousIterationData.__idata) {\n                                return { ...previousIterationData, ...scopedData };\n                            }\n                            return scopedData;\n                        }, {}),\n                        [valueName]: values[key],\n                        ...(keyName !== null ? { [keyName]: key } : {}),\n                    }, '__idata', { enumerable: false, value: true });\n                    instanceScope.unshift(iterationData);\n                    fragment.push(repeatedNode.bind(null, iterationData)());\n                    instanceScope.shift();\n                }\n                return fragment;\n            });\n        }\n        return createNodes;\n    }\n    /**\n     * Given a schema, parse it and return the resulting renderable nodes.\n     * @param data - The schema context object\n     * @param library - The available components\n     * @param node - The node to parse\n     * @returns\n     */\n    function createElements(library, schema) {\n        if (Array.isArray(schema)) {\n            const els = schema.map(createElement.bind(null, library));\n            return (iterationData) => els.map((element) => element(iterationData));\n        }\n        // Single node to render\n        const element = createElement(library, schema);\n        return (iterationData) => element(iterationData);\n    }\n    /**\n     * Data providers produced as a result of the compiler.\n     */\n    const providers = [];\n    /**\n     * Append the requisite compiler provider and return the compiled function.\n     * @param compiled - A compiled function\n     * @returns\n     */\n    function provider(compiled, hints = {}) {\n        const compiledFns = {};\n        providers.push((callback, key) => {\n            compiledFns[key] = compiled.provide((tokens) => callback(tokens, hints));\n        });\n        return () => compiledFns[instanceKey]();\n    }\n    /**\n     * Creates a new instance of a given schema \u2014 this either comes from a\n     * memoized copy of the parsed schema or a freshly parsed version. An symbol\n     * instance key, and dataProvider functions are passed in.\n     * @param providerCallback - A function that is called for each required provider\n     * @param key - a symbol representing the current instance\n     */\n    return function createInstance(providerCallback, key) {\n        const memoKey = JSON.stringify(schema);\n        const [render, compiledProviders] = has(memo, memoKey)\n            ? memo[memoKey]\n            : [createElements(library, schema), providers];\n        memo[memoKey] = [render, compiledProviders];\n        compiledProviders.forEach((compiledProvider) => {\n            compiledProvider(providerCallback, key);\n        });\n        return () => {\n            instanceKey = key;\n            return render();\n        };\n    };\n}\n/**\n * Checks the current runtime scope for data.\n * @param token - The token to lookup in the current scope\n * @param defaultValue - The default ref value to use if no scope is found.\n */\nfunction useScope(token, defaultValue) {\n    const scopedData = instanceScopes.get(instanceKey) || [];\n    let scopedValue = undefined;\n    if (scopedData.length) {\n        scopedValue = getValue(scopedData, token.split('.'));\n    }\n    return scopedValue === undefined ? defaultValue : scopedValue;\n}\n/**\n * Get the current scoped data and flatten it.\n */\nfunction slotData(data, key) {\n    return new Proxy(data, {\n        get(...args) {\n            let data = undefined;\n            const property = args[1];\n            if (typeof property === 'string') {\n                const prevKey = instanceKey;\n                instanceKey = key;\n                data = useScope(property, undefined);\n                instanceKey = prevKey;\n            }\n            return data !== undefined ? data : Reflect.get(...args);\n        },\n    });\n}\n/**\n * Provides data to a parsed schema.\n * @param provider - The SchemaProvider (output of calling parseSchema)\n * @param data - Data to fetch values from\n * @returns\n */\nfunction createRenderFn(instanceCreator, data, instanceKey) {\n    return instanceCreator((requirements, hints = {}) => {\n        return requirements.reduce((tokens, token) => {\n            if (token.startsWith('slots.')) {\n                const slot = token.substring(6);\n                const hasSlot = data.slots && has(data.slots, slot);\n                if (hints.if) {\n                    // If statement \u2014 dont render the slot, check if it exists\n                    tokens[token] = () => hasSlot;\n                }\n                else if (data.slots && hasSlot) {\n                    // Render the slot with current scope data\n                    const scopedData = slotData(data, instanceKey);\n                    tokens[token] = () => data.slots[slot](scopedData);\n                    return tokens;\n                }\n            }\n            const value = getRef(token, data);\n            tokens[token] = () => useScope(token, value.value);\n            return tokens;\n        }, {});\n    }, instanceKey);\n}\nlet i = 0;\n/**\n * The FormKitSchema vue component:\n * @public\n */\nconst FormKitSchema = defineComponent({\n    name: 'FormKitSchema',\n    props: {\n        schema: {\n            type: [Array, Object],\n            required: true,\n        },\n        data: {\n            type: Object,\n            default: () => ({}),\n        },\n        library: {\n            type: Object,\n            default: () => ({}),\n        },\n    },\n    setup(props, context) {\n        const instance = getCurrentInstance();\n        let instanceKey = Symbol(String(i++));\n        instanceScopes.set(instanceKey, []);\n        let provider = parseSchema(props.library, props.schema);\n        let render;\n        let data;\n        // Re-parse the schema if it changes:\n        watch(() => props.schema, (newSchema, oldSchema) => {\n            var _a;\n            instanceKey = Symbol(String(i++));\n            provider = parseSchema(props.library, props.schema);\n            render = createRenderFn(provider, data, instanceKey);\n            if (newSchema === oldSchema) {\n                ((_a = instance === null || instance === void 0 ? void 0 : instance.proxy) === null || _a === void 0 ? void 0 : _a.$forceUpdate)();\n            }\n        }, { deep: true });\n        // Watch the data object explicitly\n        watchEffect(() => {\n            data = Object.assign(reactive(props.data), {\n                slots: context.slots,\n            });\n            render = createRenderFn(provider, data, instanceKey);\n        });\n        return () => render();\n    },\n});\n\n/**\n * All the explicit FormKit props.\n */\nconst nativeProps = {\n    config: {\n        type: Object,\n        default: {},\n    },\n    classes: {\n        type: Object,\n        required: false,\n    },\n    delay: {\n        type: Number,\n        required: false,\n    },\n    errors: {\n        type: Array,\n        default: [],\n    },\n    inputErrors: {\n        type: Object,\n        default: () => ({}),\n    },\n    id: {\n        type: String,\n        required: false,\n    },\n    modelValue: {\n        required: false,\n    },\n    name: {\n        type: String,\n        required: false,\n    },\n    parent: {\n        type: Object,\n        required: false,\n    },\n    plugins: {\n        type: Array,\n        default: [],\n    },\n    sectionsSchema: {\n        type: Object,\n        default: {},\n    },\n    type: {\n        type: [String, Object],\n        default: 'text',\n    },\n    validation: {\n        type: [String, Array],\n        required: false,\n    },\n    validationMessages: {\n        type: Object,\n        required: false,\n    },\n    validationRules: {\n        type: Object,\n        required: false,\n    },\n    validationLabel: {\n        type: [String, Function],\n        required: false,\n    },\n};\n/**\n * The FormKit props object.\n * @internal\n */\nconst props = nativeProps;\n\n/**\n * The symbol that represents the formkit parent injection value.\n */\nconst parentSymbol = Symbol('FormKitParent');\n/**\n * The root FormKit component.\n * @public\n */\nconst FormKit = defineComponent({\n    props,\n    emits: {\n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        input: (_value) => true,\n        'update:modelValue': (_value) => true,\n        node: (node) => !!node,\n        submit: (_data, _node) => true,\n        submitRaw: (_event) => true,\n        /* eslint-enable @typescript-eslint/no-unused-vars */\n    },\n    inheritAttrs: false,\n    setup(props, context) {\n        const node = useInput(props, context);\n        if (!node.props.definition)\n            error(600, node);\n        if (node.props.definition.component) {\n            return () => {\n                var _a;\n                return h((_a = node.props.definition) === null || _a === void 0 ? void 0 : _a.component, {\n                    context: node.context,\n                }, { ...context.slots });\n            };\n        }\n        const schemaDefinition = node.props.definition.schema;\n        if (!schemaDefinition)\n            error(601, node);\n        const schema = typeof schemaDefinition === 'function'\n            ? schemaDefinition({ ...props.sectionsSchema })\n            : schemaDefinition;\n        context.emit('node', node);\n        const library = node.props.definition.library;\n        // Expose the FormKitNode to template refs.\n        context.expose({ node });\n        return () => h(FormKitSchema, { schema, data: node.context, library }, { ...context.slots });\n    },\n});\n\n/**\n * The Create a new instance of the FormKit plugin for Vue.\n * @param app - A Vue application\n * @param config - FormKit Vue plugin configuration options\n */\nfunction createPlugin(app, options) {\n    app\n        .component(options.alias || 'FormKit', FormKit)\n        .component(options.schemaAlias || 'FormKitSchema', FormKitSchema);\n    return {\n        get: getNode,\n        setLocale: (locale) => {\n            var _a;\n            if ((_a = options.config) === null || _a === void 0 ? void 0 : _a.rootConfig) {\n                options.config.rootConfig.locale = locale;\n            }\n        },\n        setErrors,\n        submit: submitForm,\n        reset,\n    };\n}\n/**\n * The symbol key for accessing the FormKit node options.\n * @public\n */\nconst optionsSymbol = Symbol.for('FormKitOptions');\n/**\n * The symbol key for accessing FormKit root configuration.\n * @public\n */\nconst configSymbol = Symbol.for('FormKitConfig');\n/**\n * Create the FormKit plugin.\n * @public\n */\nconst plugin = {\n    install(app, _options) {\n        /**\n         * Extend the default configuration options.\n         */\n        const options = Object.assign({\n            alias: 'FormKit',\n            schemaAlias: 'FormKitSchema',\n        }, typeof _options === 'function' ? _options() : _options);\n        /**\n         * The root configuration options.\n         */\n        const rootConfig = createConfig(options.config || {});\n        /**\n         * We dont want to explicitly provide any \"config\" options, only a root\n         * config option \u2014 so here we override the existing config options.\n         */\n        options.config = { rootConfig };\n        /**\n         * Register the global $formkit plugin property.\n         */\n        app.config.globalProperties.$formkit = createPlugin(app, options);\n        /**\n         * Provide the config to the application for injection.\n         */\n        app.provide(optionsSymbol, options);\n        /**\n         * Provide the root config to the application.\n         */\n        app.provide(configSymbol, rootConfig);\n    },\n};\n\n/**\n * Props that are extracted from the attrs object.\n * TODO: Currently local, this should probably exported to a inputs or another\n * package.\n */\nconst pseudoProps = [\n    'help',\n    'label',\n    'ignore',\n    'disabled',\n    'preserve',\n    /^[a-z]+(?:-visibility|Visibility)$/,\n    /^[a-zA-Z-]+(?:-class|Class)$/,\n];\n/**\n * Given some props, map those props to individualized props internally.\n * @param node - A formkit node\n * @param props - Some props that may include a classes object\n */\nfunction classesToNodeProps(node, props) {\n    if (props.classes) {\n        Object.keys(props.classes).forEach((key) => {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            node.props[`_${key}Class`] = props.classes[key];\n        });\n    }\n}\n/**\n * Extracts known FormKit listeners.\n * @param props - Extract known FormKit listeners.\n * @returns\n */\nfunction onlyListeners(props) {\n    if (!props)\n        return {};\n    const knownListeners = ['Submit', 'SubmitRaw'].reduce((listeners, listener) => {\n        const name = `on${listener}`;\n        if (name in props) {\n            if (typeof props[name] === 'function') {\n                listeners[name] = props[name];\n            }\n        }\n        return listeners;\n    }, {});\n    return knownListeners;\n}\n/**\n * A composable for creating a new FormKit node.\n * @param type - The type of node (input, group, list)\n * @param attrs - The FormKit \"props\" \u2014 which is really the attrs list.\n * @returns\n * @public\n */\nfunction useInput(props, context, options = {}) {\n    /**\n     * The configuration options, these are provided by either the plugin or by\n     * explicit props.\n     */\n    const config = Object.assign({}, inject(optionsSymbol) || {}, options);\n    /**\n     * The parent node.\n     */\n    const parent = props.parent || inject(parentSymbol, null);\n    /**\n     * The current instance.\n     */\n    const instance = getCurrentInstance();\n    /**\n     * Extracts the listeners.\n     */\n    const listeners = onlyListeners(instance === null || instance === void 0 ? void 0 : instance.vnode.props);\n    /**\n     * Define the initial component\n     */\n    const value = props.modelValue !== undefined\n        ? props.modelValue\n        : cloneAny(context.attrs.value);\n    /**\n     * Creates the node's initial props from the context, props, and definition\n     * @returns\n     */\n    function createInitialProps() {\n        const initialProps = {\n            ...nodeProps(props),\n            ...listeners,\n        };\n        const attrs = except(nodeProps(context.attrs), pseudoProps);\n        initialProps.attrs = attrs;\n        const propValues = only(nodeProps(context.attrs), pseudoProps);\n        for (const propName in propValues) {\n            initialProps[camel(propName)] = propValues[propName];\n        }\n        const classesProps = { props: {} };\n        classesToNodeProps(classesProps, props);\n        Object.assign(initialProps, classesProps.props);\n        if (typeof initialProps.type !== 'string') {\n            initialProps.definition = initialProps.type;\n            delete initialProps.type;\n        }\n        return initialProps;\n    }\n    /**\n     * Create the FormKitNode.\n     */\n    const initialProps = createInitialProps();\n    const node = createNode(extend(config || {}, {\n        name: props.name || undefined,\n        value,\n        parent: initialProps.ignore ? null : parent,\n        plugins: (config.plugins || []).concat(props.plugins),\n        config: props.config,\n        props: initialProps,\n    }, false, true));\n    /**\n     * If no definition has been assigned at this point \u2014 we're out!\n     */\n    if (!node.props.definition)\n        error(600, node);\n    /**\n     * These prop names must be assigned.\n     */\n    const pseudoPropNames = pseudoProps\n        .concat(node.props.definition.props || [])\n        .reduce((names, prop) => {\n        if (typeof prop === 'string') {\n            names.push(camel(prop));\n            names.push(kebab(prop));\n        }\n        else {\n            names.push(prop);\n        }\n        return names;\n    }, []);\n    /* Splits Classes object into discrete props for each key */\n    watchEffect(() => classesToNodeProps(node, props));\n    /**\n     * The props object already has properties even if they start as \"undefined\"\n     * so we can loop over them and individual watchEffect to prevent responding\n     * inappropriately.\n     */\n    const passThrough = nodeProps(props);\n    for (const prop in passThrough) {\n        watch(() => props[prop], () => {\n            if (props[prop] !== undefined) {\n                node.props[prop] = props[prop];\n            }\n        });\n    }\n    /**\n     * Watch \"pseudoProp\" attributes explicitly.\n     */\n    const pseudoPropsValues = only(nodeProps(context.attrs), pseudoPropNames);\n    for (const prop in pseudoPropsValues) {\n        const camelName = camel(prop);\n        watch(() => context.attrs[prop], () => {\n            node.props[camelName] = context.attrs[prop];\n        });\n    }\n    /**\n     * Watch and dynamically set attribute values, those values that are not\n     * props and are not pseudoProps\n     */\n    watchEffect(() => {\n        const attrs = except(nodeProps(context.attrs), pseudoPropNames);\n        node.props.attrs = Object.assign({}, node.props.attrs || {}, attrs);\n    });\n    /**\n     * Add any/all \"prop\" errors to the store.\n     */\n    watchEffect(() => {\n        const messages = props.errors.map((error) => createMessage({\n            key: slugify(error),\n            type: 'error',\n            value: error,\n            meta: { source: 'prop' },\n        }));\n        node.store.apply(messages, (message) => message.type === 'error' && message.meta.source === 'prop');\n    });\n    /**\n     * Add input errors.\n     */\n    if (node.type !== 'input') {\n        const sourceKey = `${node.name}-prop`;\n        watchEffect(() => {\n            const keys = Object.keys(props.inputErrors);\n            const messages = keys.reduce((messages, key) => {\n                let value = props.inputErrors[key];\n                if (typeof value === 'string')\n                    value = [value];\n                if (Array.isArray(value)) {\n                    messages[key] = value.map((error) => createMessage({\n                        key: error,\n                        type: 'error',\n                        value: error,\n                        meta: { source: sourceKey },\n                    }));\n                }\n                return messages;\n            }, {});\n            node.store.apply(messages, (message) => message.type === 'error' && message.meta.source === sourceKey);\n        });\n    }\n    /**\n     * Watch the config prop for any changes.\n     */\n    watchEffect(() => Object.assign(node.config, props.config));\n    /**\n     * Produce another parent object.\n     */\n    if (node.type !== 'input') {\n        provide(parentSymbol, node);\n    }\n    /**\n     * Explicitly watch the input value, and emit changes (lazy)\n     */\n    watch(() => { var _a; return (_a = node.context) === null || _a === void 0 ? void 0 : _a.value; }, () => {\n        var _a, _b;\n        // Emit the values after commit\n        context.emit('input', (_a = node.context) === null || _a === void 0 ? void 0 : _a.value);\n        context.emit('update:modelValue', (_b = node.context) === null || _b === void 0 ? void 0 : _b.value);\n    });\n    /**\n     * Enabled support for v-model, using this for groups/lists is not recommended\n     */\n    if (props.modelValue !== undefined) {\n        // Warning that v-model isnt the most performant for non-inputs:\n        // if (node.type !== 'input') warn()\n        watch(() => props.modelValue, (value) => {\n            node.input(value, false);\n        }, {\n            deep: true,\n        });\n    }\n    /**\n     * When this input shuts down, we need to \"delete\" the node too.\n     */\n    onUnmounted(() => node.destroy());\n    return node;\n}\n\nlet totalCreated = 1;\n/**\n * Determine if the given object is a vue component.\n *\n * @param obj - Object or function\n * @returns\n * @public\n */\nfunction isComponent(obj) {\n    return ((typeof obj === 'function' && obj.length === 2) ||\n        (typeof obj === 'object' &&\n            !Array.isArray(obj) &&\n            !('$el' in obj) &&\n            !('$cmp' in obj) &&\n            !('if' in obj)));\n}\n/**\n * Creates a new input from schema or a Vue component with the \"standard\"\n * FormKit features in place such as labels, help text, validation messages, and\n * class support.\n *\n * @param schemaOrComponent - The actual schema of the input.\n * @public\n */\nfunction createInput(schemaOrComponent, definitionOptions = {}) {\n    const definition = {\n        type: 'input',\n        ...definitionOptions,\n    };\n    let schema = undefined;\n    if (isComponent(schemaOrComponent)) {\n        const cmpName = `SchemaComponent${totalCreated++}`;\n        schema = () => ({\n            $cmp: cmpName,\n            props: {\n                context: '$node.context',\n            },\n        });\n        definition.library = { [cmpName]: markRaw(schemaOrComponent) };\n    }\n    else {\n        schema = schemaOrComponent;\n    }\n    // Use the default wrapping schema\n    definition.schema = useSchema(schema || 'Schema undefined');\n    return definition;\n}\n\n/**\n * A plugin that creates Vue-specific context object on each given node.\n * @param node - FormKitNode to create the context on.\n * @public\n */\nconst vueBindings = function vueBindings(node) {\n    /**\n     * Start a validity counter on all blocking messages.\n     */\n    node.ledger.count('blocking', (m) => m.blocking);\n    const isValid = ref(!node.ledger.value('blocking'));\n    /**\n     * Start an error message counter.\n     */\n    node.ledger.count('errors', (m) => m.type === 'error');\n    const hasErrors = ref(!!node.ledger.value('errors'));\n    /**\n     * All messages with the visibility state set to true.\n     */\n    const availableMessages = reactive(node.store.reduce((store, message) => {\n        if (message.visible) {\n            store[message.key] = message;\n        }\n        return store;\n    }, {}));\n    /**\n     * A flag that determines when validation messages should be displayed.\n     */\n    const validationVisibility = ref(node.props.validationVisibility || 'blur');\n    node.on('props:validationVisibility', ({ payload }) => {\n        validationVisibility.value = payload;\n    });\n    /**\n     * Keep track of if this input has ever shown validation errors.\n     */\n    const hasShownErrors = ref(validationVisibility.value === 'live');\n    /**\n     * The current visibility state of validation messages.\n     */\n    const validationVisible = computed(() => {\n        if (context.state.submitted)\n            return true;\n        if (!hasShownErrors.value && !context.state.settled) {\n            return false;\n        }\n        switch (validationVisibility.value) {\n            case 'live':\n                return true;\n            case 'blur':\n                return context.state.blurred;\n            case 'dirty':\n                return context.state.dirty;\n            default:\n                return false;\n        }\n    });\n    /**\n     * Determines if the input should be considered \"complete\".\n     */\n    const isComplete = computed(() => {\n        return hasValidation.value\n            ? isValid.value && !hasErrors.value\n            : context.state.dirty && !empty(context.value);\n    });\n    /**\n     * If the input has validation rules or not.\n     */\n    const hasValidation = ref(Array.isArray(node.props.parsedRules) && node.props.parsedRules.length > 0);\n    node.on('prop:parsedRules', ({ payload: rules }) => {\n        hasValidation.value = Array.isArray(rules) && rules.length > 0;\n    });\n    /**\n     * All messages that are currently on display to an end user. This changes\n     * based on the current message type visibility, like errorVisibility.\n     */\n    const messages = computed(() => {\n        const visibleMessages = {};\n        for (const key in availableMessages) {\n            const message = availableMessages[key];\n            if (message.type !== 'validation' || validationVisible.value) {\n                visibleMessages[key] = message;\n            }\n        }\n        return visibleMessages;\n    });\n    /**\n     * UI Messages.\n     */\n    const ui = reactive(node.store.reduce((messages, message) => {\n        if (message.type === 'ui' && message.visible)\n            messages[message.key] = message;\n        return messages;\n    }, {}));\n    /**\n     * This is the reactive data object that is provided to all schemas and\n     * forms. It is a subset of data in the core node object.\n     */\n    let inputElement = null;\n    const cachedClasses = reactive({});\n    const classes = new Proxy(cachedClasses, {\n        get(...args) {\n            const [target, property] = args;\n            let className = Reflect.get(...args);\n            if (!className && typeof property === 'string') {\n                if (!has(target, property) && !property.startsWith('__v')) {\n                    const observedNode = createObserver(node);\n                    observedNode.watch((node) => {\n                        const rootClasses = typeof node.config.rootClasses === 'function'\n                            ? node.config.rootClasses(property, node)\n                            : {};\n                        const globalConfigClasses = node.config.classes\n                            ? createClasses(property, node, node.config.classes[property])\n                            : {};\n                        const classesPropClasses = createClasses(property, node, node.props[`_${property}Class`]);\n                        const sectionPropClasses = createClasses(property, node, node.props[`${property}Class`]);\n                        className = generateClassList(node, property, rootClasses, globalConfigClasses, classesPropClasses, sectionPropClasses);\n                        target[property] = className;\n                    });\n                }\n            }\n            return className;\n        },\n    });\n    const describedBy = computed(() => {\n        const describers = [];\n        if (context.help) {\n            describers.push(`help-${node.props.id}`);\n        }\n        for (const key in messages.value) {\n            describers.push(`${node.props.id}-${key}`);\n        }\n        return describers.length ? describers.join(' ') : undefined;\n    });\n    const context = reactive({\n        _value: node.value,\n        attrs: node.props.attrs,\n        disabled: node.props.disabled,\n        describedBy,\n        fns: {\n            length: (obj) => Object.keys(obj).length,\n            number: (value) => Number(value),\n            string: (value) => String(value),\n            json: (value) => JSON.stringify(value),\n        },\n        handlers: {\n            blur: () => node.store.set(createMessage({ key: 'blurred', visible: false, value: true })),\n            touch: () => {\n                node.store.set(createMessage({ key: 'dirty', visible: false, value: true }));\n            },\n            DOMInput: (e) => {\n                inputElement = e.target;\n                node.input(e.target.value);\n            },\n        },\n        help: node.props.help,\n        id: node.props.id,\n        label: node.props.label,\n        messages,\n        node,\n        options: node.props.options,\n        state: {\n            blurred: false,\n            complete: isComplete,\n            dirty: false,\n            submitted: false,\n            settled: node.isSettled,\n            valid: isValid,\n            errors: hasErrors,\n            rules: hasValidation,\n            validationVisible,\n        },\n        type: node.props.type,\n        ui,\n        value: node.value,\n        classes,\n    });\n    /**\n     * Ensure the context object is properly configured after booting up.\n     */\n    node.on('created', () => {\n        if (!eq(context.value, node.value)) {\n            context._value = node.value;\n            context.value = node.value;\n        }\n    });\n    /**\n     * Sets the settled state.\n     */\n    node.on('settled', ({ payload: isSettled }) => {\n        context.state.settled = isSettled;\n    });\n    /**\n     * Observes node.props properties explicitly and updates them in the context\n     * object.\n     * @param observe - Props to observe and register as context data.\n     */\n    function observeProps(observe) {\n        observe.forEach((prop) => {\n            prop = camel(prop);\n            if (!has(context, prop) && has(node.props, prop)) {\n                context[prop] = node.props[prop];\n            }\n            node.on(`prop:${prop}`, ({ payload }) => {\n                context[prop] = payload;\n            });\n        });\n    }\n    /**\n     * We use a node observer to individually observe node props.\n     */\n    const rootProps = [\n        'help',\n        'label',\n        'disabled',\n        'options',\n        'type',\n        'attrs',\n        'id',\n    ];\n    observeProps(rootProps);\n    /**\n     * Once the input is defined, deal with it.\n     * @param definition - Type definition.\n     */\n    function definedAs(definition) {\n        if (definition.props)\n            observeProps(definition.props);\n    }\n    node.props.definition\n        ? definedAs(node.props.definition)\n        : node.on('defined', ({ payload }) => definedAs(payload));\n    /**\n     * Watch for input events from core.\n     */\n    node.on('input', ({ payload }) => {\n        context._value = payload;\n        if (inputElement) {\n            inputElement.value = context._value;\n        }\n    });\n    /**\n     * Watch for input commits from core.\n     */\n    node.on('commit', ({ payload }) => {\n        switch (node.type) {\n            case 'group':\n                context.value = { ...payload };\n                break;\n            case 'list':\n                context.value = [...payload];\n                break;\n            default:\n                context.value = payload;\n        }\n        // The input is dirty after a value has been input by a user\n        if (!context.state.dirty && node.isCreated)\n            context.handlers.touch();\n    });\n    /**\n     * Update the local state in response to messages.\n     * @param message - A formkit message\n     */\n    const updateState = async (message) => {\n        if (message.type === 'ui' &&\n            message.visible &&\n            !message.meta.showAsMessage) {\n            ui[message.key] = message;\n        }\n        else if (message.visible) {\n            availableMessages[message.key] = message;\n        }\n        else if (message.type === 'state') {\n            // await node.settled\n            context.state[message.key] = !!message.value;\n        }\n    };\n    /**\n     * Listen to message events and modify the local message data values.\n     */\n    node.on('message-added', (e) => updateState(e.payload));\n    node.on('message-updated', (e) => updateState(e.payload));\n    node.on('message-removed', ({ payload: message }) => {\n        delete ui[message.key];\n        delete availableMessages[message.key];\n        delete context.state[message.key];\n    });\n    node.on('settled:blocking', () => {\n        isValid.value = true;\n    });\n    node.on('unsettled:blocking', () => {\n        isValid.value = false;\n    });\n    node.on('settled:errors', () => {\n        hasErrors.value = false;\n    });\n    node.on('unsettled:errors', () => {\n        hasErrors.value = true;\n    });\n    /**\n     * Watch the validation visible prop and set the hasShownErrors state.\n     */\n    watch(validationVisible, (value) => {\n        if (value) {\n            hasShownErrors.value = true;\n        }\n    });\n    node.context = context;\n    // The context is complete\n    node.emit('context', node, false);\n};\n\n/**\n * Default configuration options. Includes all validation rules,\n * en i18n messages.\n * @public\n */\nconst defaultConfig = (options = {}) => {\n    const { rules = {}, locales = {}, inputs: inputs$1 = {}, messages = {}, locale = undefined, ...nodeOptions } = options;\n    /**\n     * The default configuration includes the validation plugin,\n     * with all core-available validation rules.\n     */\n    const validation = createValidationPlugin({\n        ...defaultRules,\n        ...(rules || {}),\n    });\n    /**\n     * Includes the i18n plugin with only the english language\n     * messages.\n     */\n    const i18n = createI18nPlugin(extend({ en, ...(locales || {}) }, messages));\n    /**\n     * Create the library of inputs that are generally available. This default\n     * config imports all \"native\" inputs by default, but\n     */\n    const library = createLibraryPlugin(inputs, inputs$1);\n    return extend({\n        plugins: [library, vueBindings, i18n, validation],\n        ...(!locale ? {} : { config: { locale } }),\n    }, nodeOptions || {}, true);\n};\n\nexport { FormKit, FormKitSchema, vueBindings as bindings, configSymbol, createInput, defaultConfig, optionsSymbol, plugin, useInput };\n"],
  "mappings": "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",
  "names": []
}
